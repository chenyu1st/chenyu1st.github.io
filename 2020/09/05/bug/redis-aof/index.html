<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>运维手册——Redis持久化占用磁盘过高 | 宇神之息</title><meta name="description" content="运维手册"><meta name="keywords" content="Redis,Operation Manual"><meta name="author" content="Rugod"><meta name="copyright" content="Rugod"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="crossorigin"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="运维手册——Redis持久化占用磁盘过高"><meta name="twitter:description" content="运维手册"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/redis.jpg"><meta property="og:type" content="article"><meta property="og:title" content="运维手册——Redis持久化占用磁盘过高"><meta property="og:url" content="https://rugod.com/2020/09/05/bug/redis-aof/"><meta property="og:site_name" content="宇神之息"><meta property="og:description" content="运维手册"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/redis.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://rugod.com/2020/09/05/bug/redis-aof/"><link rel="prev" title="运维手册——Dockerfile的JDK版本更换" href="https://rugod.com/2020/09/05/bug/dockerfile-jdk-version/"><link rel="next" title="Centos7安装NVIDIA显卡驱动和CUDA以及Docker-GPU环境" href="https://rugod.com/2020/08/28/gpu/nvidia-install/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a29fc1f2b32c6a60aee5dbf412c89285";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-164950732-1', 'auto');
ga('send', 'pageview');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://www.rugod.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Rugod","link":"链接: ","source":"来源: 宇神之息","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"宇神,牛逼","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/Challenger.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">66</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">73</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">20</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于本人</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#背景"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#问题分析"><span class="toc-number">2.</span> <span class="toc-text">问题分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#查阅Redis持久化机制"><span class="toc-number">2.1.</span> <span class="toc-text">查阅Redis持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB快照持久化"><span class="toc-number">2.1.1.</span> <span class="toc-text">RDB快照持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#触发RDB持久化的时机"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">触发RDB持久化的时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#save和bgsave命令"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">save和bgsave命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自动间隔触发"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">自动间隔触发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF持久化"><span class="toc-number">2.1.2.</span> <span class="toc-text">AOF持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#触发AOF持久化的时机"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">触发AOF持久化的时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF的实现"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">AOF的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF重写-rewrite"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">AOF重写(rewrite)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bgrewriteaof"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">bgrewriteaof</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF和RDB的优缺点"><span class="toc-number">2.1.3.</span> <span class="toc-text">AOF和RDB的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">RDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">AOF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反思"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">反思</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis混合持久化"><span class="toc-number">2.1.4.</span> <span class="toc-text">Redis混合持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#现状"><span class="toc-number">2.2.</span> <span class="toc-text">现状</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解决问题"><span class="toc-number">3.</span> <span class="toc-text">解决问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-写磁盘出错-Cannot-allocate-memory"><span class="toc-number">3.1.</span> <span class="toc-text">Redis 写磁盘出错 Cannot allocate memory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原因分析"><span class="toc-number">3.1.1.</span> <span class="toc-text">原因分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决问题-1"><span class="toc-number">3.1.2.</span> <span class="toc-text">解决问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#磁盘不够的问题"><span class="toc-number">3.2.</span> <span class="toc-text">磁盘不够的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置文件修改"><span class="toc-number">3.3.</span> <span class="toc-text">配置文件修改</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#改进方案"><span class="toc-number">5.</span> <span class="toc-text">改进方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一层：增加硬盘"><span class="toc-number">5.1.</span> <span class="toc-text">第一层：增加硬盘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二层：单线程的Redis"><span class="toc-number">5.2.</span> <span class="toc-text">第二层：单线程的Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三层：从技术选型上思考"><span class="toc-number">5.3.</span> <span class="toc-text">第三层：从技术选型上思考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">6.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/redis.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">宇神之息</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于本人</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">运维手册——Redis持久化占用磁盘过高</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-09-05 17:53:33"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-09-05</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-09-05 18:28:10"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-09-05</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">7.3k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 26 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/09/05/bug/redis-aof/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/09/05/bug/redis-aof/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>声明:这是我在大学毕业后进入第二家互联网公司学习的内容</p>
<hr>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>公司服务器ES写索引异常，查看原因，发现ES数据所在目录磁盘空间使用率超过百分之90后，ES将修改为只读状态，所以判断是磁盘空间满了。然后我上服务器看，Redis占用了300G+磁盘，且Redis做AOF和RDB混合持久化，AOF 137G RDB 123G</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><h2 id="查阅Redis持久化机制"><a href="#查阅Redis持久化机制" class="headerlink" title="查阅Redis持久化机制"></a>查阅Redis持久化机制</h2><p>Redis提供了两种持久化方案：RDB持久化和AOF持久化，一个是快照的方式，一个是类似日志追加的方式</p>
<h3 id="RDB快照持久化"><a href="#RDB快照持久化" class="headerlink" title="RDB快照持久化"></a>RDB快照持久化</h3><p>RDB持久化是通过快照的方式，即在指定的时间间隔内将内存中的数据集快照写入磁盘。在创建快照之后，用户可以备份该快照，可以将快照复制到其他服务器以创建相同数据的服务器副本，或者在重启服务器后恢复数据。RDB是Redis默认的持久化方式</p>
<p>RDB持久化会生成RDB文件，该文件是一个压缩过的二进制文件，可以通过该文件还原快照时的数据库状态，即生成该RDB文件时的服务器数据。RDB文件默认为当前工作目录下的dump.rdb，可以根据配置文件中的dbfilename和dir设置RDB的文件名和文件位置</p>
<h4 id="触发RDB持久化的时机"><a href="#触发RDB持久化的时机" class="headerlink" title="触发RDB持久化的时机"></a>触发RDB持久化的时机</h4><ul>
<li>执行save和bgsave命令</li>
<li>配置文件设置save <seconds> <changes>规则，自动间隔性执行bgsave命令</li>
<li>主从复制时，从库全量复制同步主库数据，主库会执行bgsave</li>
<li>执行flushall命令清空服务器数据</li>
<li>执行shutdown命令关闭Redis时，会执行save命令</li>
</ul>
<h4 id="save和bgsave命令"><a href="#save和bgsave命令" class="headerlink" title="save和bgsave命令"></a>save和bgsave命令</h4><p>执行save和bgsave命令，可以手动触发快照，生成RDB文件，两者的区别如下</p>
<p>使用save命令会阻塞Redis服务器进程，服务器进程在RDB文件创建完成之前是不能处理任何的命令请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; save</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>复制代码而使用bgsave命令不同的是，basave命令会fork一个子进程，然后该子进程会负责创建RDB文件，而服务器进程会继续处理命令请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bgsave</span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure>

<p>fork()是由操作系统提供的函数，作用是创建当前进程的一个副本作为子进程</p>
<p>fork一个子进程，子进程会把数据集先写入临时文件，写入成功之后，再替换之前的RDB文件，用二进制压缩存储，这样可以保证RDB文件始终存储的是完整的持久化内容。</p>
<p>如图所示</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Redis/rdb.png"  alt="rdb.png"></p>
<h4 id="自动间隔触发"><a href="#自动间隔触发" class="headerlink" title="自动间隔触发"></a>自动间隔触发</h4><p>在配置文件中设置save <seconds> <changes>规则，可以自动间隔性执行bgsave命令，且不会造成Redis堵塞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>save <seconds> <changes>表示在seconds秒内，至少有changes次变化，就会自动触发gbsave命令</p>
<ul>
<li>save 900 1  当时间到900秒时，如果至少有1个key发生变化，就会自动触发bgsave命令创建快照</li>
<li>save 300 10  当时间到300秒时，如果至少有10个key发生变化，就会自动触发bgsave命令创建快照</li>
<li>save 60 10000    当时间到60秒时，如果至少有10000个key发生变化，就会自动触发bgsave命令创建快照</li>
</ul>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>除了RDB持久化，Redis还提供了AOF（Append Only File）持久化功能，AOF持久化会把被执行的写命令写到AOF文件的末尾，记录数据的变化。默认情况下，Redis是没有开启AOF持久化的，开启后，每执行一条更改Redis数据的命令，都会把该命令追加到AOF文件中，这是会降低Redis的性能，但大部分情况下这个影响是能够接受的，另外使用较快的硬盘可以提高AOF的性能</p>
<h4 id="触发AOF持久化的时机"><a href="#触发AOF持久化的时机" class="headerlink" title="触发AOF持久化的时机"></a>触发AOF持久化的时机</h4><ul>
<li>配置文件开启AOF即可</li>
</ul>
<p>配置文件如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># appendonly参数开启AOF持久化</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># AOF持久化的文件名，默认是appendonly.aof</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span><br><span class="line">dir .&#x2F;</span><br><span class="line"></span><br><span class="line"># 同步策略</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># aof重写期间是否同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 加载aof出错如何处理</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"># 文件重写策略</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>


<h4 id="AOF的实现"><a href="#AOF的实现" class="headerlink" title="AOF的实现"></a>AOF的实现</h4><p>AOF需要记录Redis的每个写命令，步骤为：命令追加（append）、文件写入（write）和文件同步（sync）</p>
<ul>
<li>命令追加(append)</li>
</ul>
<p>开启AOF持久化功能后，服务器每执行一个写命令，都会把该命令以协议格式先追加到aof_buf缓存区的末尾，而不是直接写入文件，避免每次有命令都直接写入硬盘，减少硬盘IO次数</p>
<ul>
<li>文件写入(write)和文件同步(sync)</li>
</ul>
<p>对于何时把aof_buf缓冲区的内容写入保存在AOF文件中，Redis提供了多种策略</p>
<p>appendfsync always：将aof_buf缓冲区的所有内容写入并同步到AOF文件，每个写命令同步写入磁盘</p>
<p>appendfsync everysec：将aof_buf缓存区的内容写入AOF文件，每秒同步一次，该操作由一个线程专门负责</p>
<p>appendfsync no：将aof_buf缓存区的内容写入AOF文件，什么时候同步由操作系统来决定</p>
<p>appendfsync选项的默认配置为everysec，即每秒执行一次同步</p>
<p>关于AOF的同步策略是涉及到操作系统的write函数和fsync函数的，在《Redis设计与实现》中是这样说明的</p>
<p>为了提高文件写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。</p>
<p>这样的操作虽然提高了效率，但也为数据写入带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失。为此，系统提供了fsync、fdatasync同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保写入数据的安全性。</p>
<p>从上面的介绍我们知道，我们写入的数据，操作系统并不一定会马上同步到磁盘，所以Redis才提供了appendfsync的选项配置。当该选项时为always时，数据安全性是最高的，但是会对磁盘进行大量的写入，Redis处理命令的速度会受到磁盘性能的限制；appendfsync everysec选项则兼顾了数据安全和写入性能，以每秒一次的频率同步AOF文件，即便出现系统崩溃，最多只会丢失一秒内产生的数据；如果是appendfsync no选项，Redis不会对AOF文件执行同步操作，而是有操作系统决定何时同步，不会对Redis的性能带来影响，但假如系统崩溃，可能会丢失不定数量的数据</p>
<h4 id="AOF重写-rewrite"><a href="#AOF重写-rewrite" class="headerlink" title="AOF重写(rewrite)"></a>AOF重写(rewrite)</h4><p>由于AOF的机制，每条写命令都需要被记录，如果一对kv先被创建，然后被修改4次，最后被删除，那么AOF会存在6个此kv的记录。</p>
<p>如果此时Redis重启，读取AOF，那么最终还是不会存在这对kv，但是AOF的文件大小会增大（因为记录了这6条命令）</p>
<p>为了不让AOF一直增大至无限大，Redis应该让删除这些不必要的命令（冗余命令）。比如：过期数据的命令、无效的命令（重复设置、删除）、多个命令可合并为一个命令（批处理命令）</p>
<p>AOF重写的目的就是减小AOF文件的体积，不过值得注意的是：AOF文件重写并不需要对现有的AOF文件进行任何读取、分享和写入操作，而是通过读取服务器当前的数据库状态来实现的</p>
<p>文件重写可分为手动触发和自动触发，手动触发执行bgrewriteaof命令，该命令的执行跟bgsave触发快照时类似的，都是先fork一个子进程做具体的工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bgrewriteaof</span><br><span class="line">Background append only file rewriting started</span><br></pre></td></tr></table></figure>

<p>自动触发会根据auto-aof-rewrite-percentage和auto-aof-rewrite-min-size 64mb配置来自动执行bgrewriteaof命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 重写触发配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<p>这个配置表示当AOF文件的体积大于64MB，且AOF文件的体积比上一次重写后的体积大了一倍（100%）时，会执行<code>bgrewriteaof</code>命令</p>
<h4 id="bgrewriteaof"><a href="#bgrewriteaof" class="headerlink" title="bgrewriteaof"></a>bgrewriteaof</h4><p>重写会有大量的写入操作，所以服务器进程会fork一个子进程来创建一个新的AOF文件</p>
<p>在重写期间，服务器进程继续处理命令请求，如果有写入的命令，追加到aof_buf的同时，还会追加到aof_rewrite_buf AOF重写缓冲区</p>
<p>当子进程完成重写之后，会给父进程一个信号，然后父进程会把AOF重写缓冲区的内容写进新的AOF临时文件中，再对新的AOF文件改名完成替换，这样可以保证新的AOF文件与当前数据库数据的一致性</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Redis/aof.png"  alt="aof.png"></p>
<h3 id="AOF和RDB的优缺点"><a href="#AOF和RDB的优缺点" class="headerlink" title="AOF和RDB的优缺点"></a>AOF和RDB的优缺点</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>优点：</p>
<ul>
<li>RDB 是一个非常紧凑（compact）的文件，体积小，因此在传输速度上比较快，因此适合灾难恢复。 </li>
<li>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</li>
<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
</ul>
<p>缺点：</p>
<ul>
<li>RDB是一个快照过程，无法完整的保存所以数据，尤其在数据量比较大时候，一旦出现故障丢失的数据将更多。</li>
<li>当redis中数据集比较大时候，RDB由于RDB方式需要对数据进行完成拷贝并生成快照文件，fork的子进程会耗CPU，并且数据越大，RDB快照生成会越耗时。</li>
<li>RDB文件是特定的格式，阅读性差，由于格式固定，可能存在不兼容情况。</li>
</ul>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>优点：</p>
<ul>
<li>数据更完整，秒级数据丢失(取决于设置fsync策略)。</li>
<li>兼容性较高，由于是基于redis通讯协议而形成的命令追加方式，无论何种版本的redis都兼容，再者aof文件是明文的，可阅读性较好。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据文件体积较大,即使有重写机制，但是在相同的数据集情况下，AOF文件通常比RDB文件大。</li>
<li>相对RDB方式，AOF速度慢于RDB，并且在数据量大时候，恢复速度AOF速度也是慢于RDB。</li>
<li>由于频繁地将命令同步到文件中，AOF持久化对性能的影响相对RDB较大，但是对于我们来说是可以接受的。</li>
</ul>
<h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><p>通过AOF和RDB的优缺点比较，其实我关注的重点就是数据恢复的可靠性。</p>
<p>一台服务器如果你能保证永久不关机、不中断服务。那么这台机器就不需要做任何备份（实际基本上不存在这种）</p>
<p>那么一旦出现中断服务、或关机、或硬盘损失。我们就应该关注如何让这个服务恢复到正常状态最佳。</p>
<p>这个最佳的定义，在学习SRE的思想后，我是这样看的</p>
<ul>
<li>数据尽量不丢失</li>
<li>恢复的时间尽快</li>
</ul>
<p>这样才能对生产影响最小。</p>
<p>基于这个原则，Redis的备份策略应该吸收RDB(恢复速度快)、AOF(数据不丢失)这2个最重要的优点。</p>
<p>仔细研究发现这个备份策略已经实现了，那就是Redis的混合持久化</p>
<h3 id="Redis混合持久化"><a href="#Redis混合持久化" class="headerlink" title="Redis混合持久化"></a>Redis混合持久化</h3><p>Redis4.0开始支持RDB和AOF的混合持久化（可以通过配置项 aof-use-rdb-preamble 开启）5.0之后默认开启混合持久化</p>
<p>混合持久化同样也是通过bgrewriteaof完成的，不同的是当开启混合持久化时，fork出的子进程先将共享的内存副本全量的以RDB方式写入aof文件，然后在将aof_rewrite_buf重写缓冲区的增量命令以AOF方式写入到文件，写入完成后通知主进程更新统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件。简单的说：新的AOF文件前半段是RDB格式的全量数据后半段是AOF格式的增量数据。</p>
<p>如下图所示：</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Redis/aof-use-rdb-preamble.png"  alt="aof-use-rdb-preamble.png"></p>
<p>那么重启时redis按照以下规则读取数据</p>
<ul>
<li>如果是redis进程挂掉，那么重启redis进程即可，直接基于AOF日志文件恢复数据</li>
<li>如果是redis进程所在机器挂掉，那么重启机器后，尝试重启redis进程，尝试直接基于AOF日志文件进行数据恢复，如果AOF文件破损，那么用redis-check-aof fix命令修复</li>
<li>如果没有AOF文件，会去加载RDB文件</li>
<li>如果redis当前最新的AOF和RDB文件出现了丢失/损坏，那么可以尝试基于该机器上当前的某个最新的RDB数据副本进行数据恢复</li>
</ul>
<p>通过这些规则我们可以知道即使是混合持久化，在不丢失/破坏AOF的情况下，再持久化一份RDB几乎没用。因为开启了混合模式后的aof文件里包含了rdb的头+aof的增量文件，而每次重启读取的都是aof文件。</p>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>目前Redis服务器是做了AOF和RDB混合持久化。磁盘439G 内存256G</p>
<p>我们先查看服务器状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ free -h</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           251G        151G        858M        730M         99G         97G</span><br><span class="line">$ df -h</span><br><span class="line">Filesystem    Size  Used Avail Use% Mounted on</span><br><span class="line">udev          126G     0  126G   0% &#x2F;dev</span><br><span class="line">tmpfs         26G   1.7G   24G   7%  &#x2F;run</span><br><span class="line">&#x2F;dev&#x2F;sdc2     439G  400G  38G   91% &#x2F;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; INFO Memory</span><br><span class="line"># Memory</span><br><span class="line">used_memory:144520234248</span><br><span class="line">used_memory_human:134.59G</span><br><span class="line">used_memory_rss:151639486464</span><br><span class="line">used_memory_rss_human:141.23G</span><br><span class="line">used_memory_peak:145837846640</span><br><span class="line">used_memory_peak_human:135.82G</span><br><span class="line">used_memory_peak_perc:99.10%</span><br><span class="line">used_memory_overhead:46702054</span><br><span class="line">used_memory_startup:786608</span><br><span class="line">used_memory_dataset:144473532194</span><br><span class="line">used_memory_dataset_perc:99.97%</span><br><span class="line">total_system_memory:270115205120</span><br><span class="line">total_system_memory_human:251.56G</span><br><span class="line">used_memory_lua:37888</span><br><span class="line">used_memory_lua_human:37.00K</span><br><span class="line">maxmemory:0</span><br><span class="line">maxmemory_human:0B</span><br><span class="line">maxmemory_policy:volatile-ttl</span><br><span class="line">mem_fragmentation_ratio:1.05</span><br><span class="line">mem_allocator:jemalloc-4.0.3</span><br><span class="line">active_defrag_running:0</span><br><span class="line">lazyfree_pending_objects:0</span><br></pre></td></tr></table></figure>

<p>好家伙，Redis实际使用了134.59G</p>
<p>那么我们看看Redis的备份文件大小吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ll -rth</span><br><span class="line">total 383G</span><br><span class="line">drwxrwxr-x 2 ubuntu ubuntu 4.0K 6月  18 18:44 log&#x2F;</span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu  41K 7月  11 13:25 redis.conf</span><br><span class="line">-rw-r--r-- 1 root   root   866M 9月   3 12:22 temp-1.rdb</span><br><span class="line">drwxr-xr-x 3 root   root   4.0K 9月   3 12:29 ..&#x2F;</span><br><span class="line">-rw-r--r-- 1 root   root   123G 9月   4 20:10 dump.rdb</span><br><span class="line">drwxrwxr-x 3 ubuntu ubuntu 4.0K 9月   4 20:15 .&#x2F;</span><br><span class="line">-rw-r--r-- 1 root   root   137G 9月   4 20:38 appendonly.aof</span><br><span class="line">-rw-r--r-- 1 root   root   123G 9月   4 20:39 temp-75.rdb</span><br></pre></td></tr></table></figure>

<p>真的很顶 383G</p>
<p>通过dump.rdb和temp-75.rdb我们可以看出，Redis确实是一直在备份的，且AOF的大小比RDB大</p>
<p>那我们继续看看这个redis的备份策略吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 300 10</span><br><span class="line">auto-aof-rewrite-percentage 30</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<p>那么就说明了 每6分钟只要存在 10对kv发生了改变就会备份RDB文件</p>
<p>每当实时的AOF文件大小比上次重写的AOF文件大百分之30，就会重写AOF</p>
<p>对于一个经常发生更改的Redis来说</p>
<p>save 300 10的配置，每6分钟就要刷一次盘，这个配置真是让人窒息。</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><h2 id="Redis-写磁盘出错-Cannot-allocate-memory"><a href="#Redis-写磁盘出错-Cannot-allocate-memory" class="headerlink" title="Redis 写磁盘出错 Cannot allocate memory"></a>Redis 写磁盘出错 Cannot allocate memory</h2><p>先查看Redis日志，发现存在大量报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1:M 03 Sep 02:55:23.877 # Can&#39;t rewrite append only file in background: fork: Cannot allocate memory</span><br><span class="line">1:M 03 Sep 02:55:23.978 * Starting automatic rewriting of AOF on 198% growth</span><br><span class="line">1:M 03 Sep 02:55:23.978 # Can&#39;t rewrite append only file in background: fork: Cannot allocate memory</span><br><span class="line">1:M 03 Sep 02:55:24.078 * 10 changes in 300 seconds. Saving...</span><br><span class="line">1:M 03 Sep 02:55:24.079 # Can&#39;t save in background: fork: Cannot allocate memory</span><br><span class="line">1:M 03 Sep 02:55:24.079 * Starting automatic rewriting of AOF on 198% growth</span><br><span class="line">1:M 03 Sep 02:55:24.079 # Can&#39;t rewrite append only file in background: fork: Cannot allocate memory</span><br><span class="line">1:M 03 Sep 02:55:24.179 * Starting automatic rewriting of AOF on 198% growth</span><br><span class="line">1:M 03 Sep 02:55:24.179 # Can&#39;t rewrite append only file in background: fork: Cannot allocate memory</span><br><span class="line">1:M 03 Sep 02:55:24.280 * Starting automatic rewriting of AOF on 198% growth</span><br></pre></td></tr></table></figure>

<p>google查看原因</p>
<p>异步回写(BGSAVE), 主进程fork后, 复制自身并通过这个新的进程回写磁盘, 回写结束后新进程自行关闭.</p>
<p>由于 BGSAVE 不需要主进程阻塞, 系统也不会假死, 一般会采用 BGSAVE 来实现数据回写.</p>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>在离线作业运行过程中，随着list中数据量增加，Redis内存占用逐渐增加；</p>
<p>当系统剩余内存不足以fork子进程时，AOF重写子进程启动失败，此时错误log为“Can’t rewrite append only file in background: fork: Cannot allocate memory”，而用于父子进程通信的pipe不知什么原因没有关闭；</p>
<p>Redis不断尝试启动AOF重写子进程，终于在数小时后将允许的fd数耗尽，此时错误log为“Error opening /setting AOF rewrite IPC pipes: Numerical result out of range”；</p>
<p>与此同时，随着离线作业的完成，内存占用已经下降，但由于fd不足，AOF重写子进程还是不能启动；</p>
<h3 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h3><p>最后参考网上资料</p>
<p>不改代码的规避方案：</p>
<ul>
<li>设置linux系统的vm.overcommit_memory = 1（其意义可查阅man手册，本文不再展开），尽量减少子进程fork失败的情况；</li>
<li>设置Redis的maxmemory限制，当内存使用达到一定比例时不再接受新的数据；</li>
<li>使用主从备份，或bgsave持久化（RDB方式无此问题），关闭AOF持久化，等下一版本发布。</li>
</ul>
<p>首先Redis是maxmemory限制，同时说过领导要求不限制Redis的最大使用率，不考虑</p>
<p>目前Redis单机，改成主从或者集群不显示，不考虑</p>
<p>那么只有改vm.overcommit_memory了</p>
<p>这个涉及到了linux内核的知识</p>
<p>简单说下 vm.overcommit_memory这个参数</p>
<ul>
<li>vm.overcommit_memory = 1，直接放行</li>
<li>vm.overcommit_memory = 0：则比较 此次请求分配的虚拟内存大小和系统当前空闲的物理内存加上swap，决定是否放行。</li>
<li>vm.overcommit_memory = 2：则会比较进程所有已分配的虚拟内存加上此次请求分配的虚拟内存和系统当前的空闲物理内存加上swap，决定是否放行。</li>
</ul>
<p>那么查看服务器的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -a|grep  vm.overcommit_memory</span><br><span class="line">vm.overcommit_memory &#x3D; 0</span><br></pre></td></tr></table></figure>

<p>将其改为1即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo echo &#39;vm.overcommit_memory &#x3D; 1&#39; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure>

<h2 id="磁盘不够的问题"><a href="#磁盘不够的问题" class="headerlink" title="磁盘不够的问题"></a>磁盘不够的问题</h2><p>解决完上面一个问题，我发现Redis的日志开始重写了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1:M 03 Sep 02:55:30.710 * Background append only file rewriting started by pid 3025</span><br><span class="line">1:M 03 Sep 03:19:51.718 * AOF rewrite child asks to stop sending diffs.</span><br><span class="line">3025:C 03 Sep 03:19:51.719 * Parent agreed to stop sending diffs. Finalizing AOF...</span><br><span class="line">3025:C 03 Sep 03:19:51.719 * Concatenating 18.88 MB of AOF diff received from parent.</span><br><span class="line">3025:C 03 Sep 03:19:51.871 * SYNC append only file rewrite performed</span><br><span class="line">3025:C 03 Sep 03:19:54.247 * AOF rewrite: 965 MB of memory used by copy-on-write</span><br><span class="line">1:M 03 Sep 03:19:57.266 * Background AOF rewrite terminated with success</span><br><span class="line">1:M 03 Sep 03:19:57.266 * Residual parent diff successfully flushed to the rewritten AOF (0.00 MB)</span><br><span class="line">1:M 03 Sep 03:19:57.266 * Background AOF rewrite finished successfully</span><br><span class="line">1:M 03 Sep 03:19:57.367 * 10 changes in 300 seconds. Saving...</span><br></pre></td></tr></table></figure>
<p>大概花了25分钟时间，才把100多G的文件备份下来</p>
<p>在第二次重写的时候我发现磁盘已经打满了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1:M 03 Sep 03:20:01.234 * Background saving started by pid 3032</span><br><span class="line">3032:C 03 Sep 03:40:25.708 * DB saved on disk</span><br><span class="line">3032:C 03 Sep 03:40:28.021 * RDB: 667 MB of memory used by copy-on-write</span><br><span class="line">1:M 03 Sep 03:40:30.921 * Background saving terminated with success</span><br><span class="line">1:M 03 Sep 03:45:31.094 * 10 changes in 300 seconds. Saving...</span><br><span class="line">1:M 03 Sep 03:45:35.168 * Background saving started by pid 3033</span><br><span class="line">3033:C 03 Sep 04:05:47.989 # Write error saving DB on disk: No space left on device</span><br></pre></td></tr></table></figure>

<p>因为RDB备份是在保存一份的情况，重写一个RDB文件，然后删除之前的文件。这就意味着在最高峰的时候你得存在2倍内存大小的磁盘文件，然后再加上一个AOF文件</p>
<p>也就是说如果内存中存了100G，你要保证磁盘空间大于130*3=390G 甚至更多。</p>
<h2 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h2><p>由于上面分析的混合存储的机制，不需要再单独备份RDB了，所以我们选择根本解决问题，关闭单独备份RDB策略。</p>
<p>将redis.conf文件save注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save &quot;&quot;</span><br><span class="line"></span><br><span class="line">#save 900 1</span><br><span class="line">#save 300 10</span><br><span class="line">#save 60 10000</span><br></pre></td></tr></table></figure>

<p>但是没有重启redis（因为重启速度太慢了）</p>
<p>进入redis—cli</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set save &quot;&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>


<p>然后在redis存放文件的目录下删除已生成的文件 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;data&#x2F;redis&#x2F;data$ rm -rf *.rdb</span><br></pre></td></tr></table></figure>

<p>tail -f redis-server.log</p>
<p>发现最后一次生成后，再不存在自动备份rdb的日志了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>问题最终是解决了，ES已经可以正常工作了，复盘这个问题往往才是最让人成长的时刻。</p>
<p>关于这个案例，从定位到解决问题我分了3步</p>
<ul>
<li>开发人员反馈线上功能异常，查看代码文件发现ES不可用，分析原因是磁盘占用率超过百分之90导致</li>
<li>我收到这个异常反馈，进入服务器，查看服务器资源使用量，内存占用过高，磁盘占用快满了，简单查询资料，分析得出删除RDB文件并且关闭RDB持久化策略</li>
<li>通知同事，服务器会修复一段时间，可能造成停机的问题，完成异常修复</li>
</ul>
<h1 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h1><p>要成为一个SRE，这个问题的解决肯定不止于此。</p>
<p>运维站的角度越高，看的问题越清晰。</p>
<h2 id="第一层：增加硬盘"><a href="#第一层：增加硬盘" class="headerlink" title="第一层：增加硬盘"></a>第一层：增加硬盘</h2><p>由于Redis内存占用很高，备份文件磁盘也自然很大，所以我选择了加一块硬盘，然后将Redis的日志dir挂载到这块盘里。</p>
<p>步骤</p>
<ul>
<li>先添加一块硬盘并格式化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk -l</span><br><span class="line">Disk &#x2F;dev&#x2F;sda: 7.3 TiB, 8001563222016 bytes, 15628053168 sectors</span><br><span class="line">Units: sectors of 1 * 512 &#x3D; 512 bytes</span><br><span class="line">Sector size (logical&#x2F;physical): 512 bytes &#x2F; 4096 bytes</span><br><span class="line">I&#x2F;O size (minimum&#x2F;optimal): 4096 bytes &#x2F; 4096 bytes</span><br><span class="line"></span><br><span class="line">$ fdisk &#x2F;dev&#x2F;sda </span><br><span class="line">$ mkfs.ext4 &#x2F;dev&#x2F;sda1</span><br><span class="line">$ mount &#x2F;dev&#x2F;sda1 &#x2F;data</span><br><span class="line"></span><br><span class="line">$ vim  &#x2F;etc&#x2F;fstab 添加一行开机自动挂载 </span><br><span class="line">&#x2F;dev&#x2F;sdb1 &#x2F;data ext4 defaults  0  2</span><br><span class="line"></span><br><span class="line">$ fdisk -l</span><br><span class="line">Disk &#x2F;dev&#x2F;sda: 7.3 TiB, 8001563222016 bytes, 15628053168 sectors</span><br><span class="line">Units: sectors of 1 * 512 &#x3D; 512 bytes</span><br><span class="line">Sector size (logical&#x2F;physical): 512 bytes &#x2F; 4096 bytes</span><br><span class="line">I&#x2F;O size (minimum&#x2F;optimal): 4096 bytes &#x2F; 4096 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0xb95afa0a</span><br><span class="line"></span><br><span class="line">Device     Boot Start        End    Sectors Size Id Type</span><br><span class="line">&#x2F;dev&#x2F;sda1        2048 4294967294 4294965247   2T 83 Linux</span><br></pre></td></tr></table></figure>
<ul>
<li><p>将原来Redis存储文件放到新添加的硬盘里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mv &#x2F;opt&#x2F;redis&#x2F;data&#x2F; &#x2F;data&#x2F;redis&#x2F;</span><br><span class="line">$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            126G     0  126G   0% &#x2F;dev</span><br><span class="line">tmpfs           26G   1.7G  24G    7% &#x2F;run</span><br><span class="line">&#x2F;dev&#x2F;sdc2       439G  104G  313G  25% &#x2F;</span><br><span class="line">&#x2F;dev&#x2F;sda1       2.0T  153G  1.8T   8% &#x2F;data</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启redis，开启新生活吧~</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti -v &#x2F;data&#x2F;redis&#x2F;data:&#x2F;data&#x2F; -p 6379:6379 --name redis -d redis:4.0.14 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-server &#x2F;data&#x2F;redis.conf</span><br></pre></td></tr></table></figure>

<h2 id="第二层：单线程的Redis"><a href="#第二层：单线程的Redis" class="headerlink" title="第二层：单线程的Redis"></a>第二层：单线程的Redis</h2><p>我在观察redis.log时还发现一些异常，并且频率很高，抱着寻根问底的思想去查看这个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.</span><br></pre></td></tr></table></figure>

<p>google后发现<br>该错误可能会造成 redis server 上的处理延迟，而且客户端上也可能发生异常或连接超时。</p>
<p>这妥妥的是一个生产BUG啊</p>
<p>继续深入发现，这是因为启用了RDB SAVE 300 10</p>
<p>也就是每300秒出现10个kv更改就会刷盘的备份策略</p>
<p>造成的磁盘 I/O 负载高。</p>
<p>虽然这个问题已经被我解决了，但是我继续了解了Redis的内部机制后发现这其实是一个使用Redis不到位的缺陷。</p>
<p>大家往往使用Redis是因为Redis快——数据都是加载在内存中的，但是很少有人会深入了解Redis的实现逻辑。</p>
<p>Redis 是一个多路复用的单进程应用程序。多路，指的是多个网络地址，复用是指重复利用单个线程。</p>
<p>当打开持久化功能后， Redis 处理完每个事件后会调用 write(2) 将变化写入 kernel 的 buffer，如果此时 write(2) 被阻塞，Redis 就不能处理下一个事件。Linux 规定执行 write(2) 时，如果对同一个文件正在执行fdatasync(2)将 kernel buffer写入物理磁盘，或者有system wide sync在执行，write(2)会被Block住，整个Redis被Block住。</p>
<p>如果系统IO 繁忙，比如有别的应用在写盘，或者Redis自己在重写AOF 或备份RDB，就可能导致 fdatasync(2) 迟迟未能完成从而 Block 住 write(2)，Block 住整个 Redis。</p>
<p>为此Redis提供了一个自救的方式，当发现文件有在执行 fdatasync(2) 时，就先不调用 write(2)，只存在 cache 里，免得被 Block。但如果已经超过两秒都还是这个样子，则会硬着头皮执行 write(2)，即使 redis 会被 Block 住。此时那句要命的 log 会打印：”Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.”。之后用redis-cli INFO 可以看到 aof_delayed_fsync 的值被加1。因此，对于 fsync 设为 everysec 时丢失数据的可能性的最严谨说法是：如果有 fdatasync 在长时间的执行，此时 redis 意外关闭会造成文件里不多于两秒的数据丢失。如果 fdatasync 运行正常，redis 意外关闭没有影响，只有当操作系统 crash 时才会造成少于1秒的数据丢失。</p>
<p>这个问题还是比较难理解的，我总结下即使是AOF开启了everysec：秒级备份，仍然会丢数据的问题，是由于存在磁盘IO过高造成请求堵塞的情况。</p>
<p>而网上对这个问题给出的解决意见也很真实</p>
<p>参考文献<br><a href="https://segmentfault.com/a/1190000016096933" target="_blank" rel="noopener">关于Redis的aof持久化的二三事</a></p>
<ul>
<li>关闭 RDB 或 AOF 持久化</li>
</ul>
<p>而已经开启了混合持久化策略的Redis直接关闭RDB备份即可解决</p>
<ul>
<li>从操作系统层面优化：修改内核参数</li>
</ul>
<p>又到了学习linux内核参数的时候了，哈哈</p>
<p>AOF rewrite是一直埋头的调用 write(2)，由系统自己去触发 sync。</p>
<p>默认配置vm.dirty_background_ratio=10，也就是占用了 10% 的可用内存才会开始后台 flush，256*10%=25.6G</p>
<p>很明显一次flush太多数据会造成堵塞</p>
<p>看了下网上的建议都是将刷新大小写为32M</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -a | grep dirty_background_ratio</span><br><span class="line">vm.dirty_background_ratio &#x3D; 10</span><br><span class="line"> </span><br><span class="line">$ sysctl -a | grep vm.dirty_bytes</span><br><span class="line">vm.dirty_bytes &#x3D; 0</span><br><span class="line"></span><br><span class="line">$ echo &quot;vm.dirty_bytes&#x3D;33554432&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure>

<h2 id="第三层：从技术选型上思考"><a href="#第三层：从技术选型上思考" class="headerlink" title="第三层：从技术选型上思考"></a>第三层：从技术选型上思考</h2><p>这一层其实是最难的，我在思考为什么Redis会存上百G的文件，还是用的单机Docker安装的。同事告诉我Redis是存图片，我寻思存图片不是用文件存储服务器吗（比如阿里云的OSS、AWS的S3、或者本地自建的文件系统）？同事告诉我图片是存储在AWS的S3上的，但是应用程序在国内，直接访问图片速度很慢</p>
<p>后来了解到，由于架构需要，中美之间的网络传输速度慢、不稳定，导致应用服务不能直接从S3访问，而且AWS的CDN也没有开放国内的站点加速，一张图片20多M加载速度慢，确实很难处理。</p>
<p>而且程序传图片一般是在国内晚上，从S3上拉图片经过程序最终存到Redis里，然后在白天的时候，项目人员可以直接访问Redis里的图片，速度会比直接从S3访问快很多。</p>
<p>但是用Redis太浪费资源了，一台32c 256g的服务器就装了Redis，作为一个特别喜欢薅羊毛的运维工程师，我对此表示：真的有钱。</p>
<p>因此我查看了网上的资料，得出2个解决此问题的办法</p>
<ul>
<li>增加公司网络带宽，硬方法处理</li>
<li>本地自建文件存储系统，用图片缓存功能，保证用户每次请求同样的资源不用去Redis里读取，而应该直接读图片缓存服务器，最经典的例子就是Nginx做静态资源服务器。</li>
</ul>
<p>第三层的处理过程我们留在下期运维实践里细说吧</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://redis.io/topics/persistence" target="_blank" rel="noopener">Redis官网持久化说明</a></p>
<p><a href="https://www.cnblogs.com/wdliu/p/9377278.html" target="_blank" rel="noopener">Redis4.0深入持久化</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/39412293" target="_blank" rel="noopener">Redis持久化方案该如何选型</a></p>
<p><a href="https://www.jianshu.com/p/d03216c0150b" target="_blank" rel="noopener">Redis 写磁盘出错 Cannot allocate memory</a></p>
<p><a href="https://segmentfault.com/a/1190000016096933" target="_blank" rel="noopener">关于Redis的aof持久化的二三事</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Rugod</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rugod.com/2020/09/05/bug/redis-aof/">https://rugod.com/2020/09/05/bug/redis-aof/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rugod.com" target="_blank">宇神之息</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/Operation-Manual/">Operation Manual</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/human-jump.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/wechat.JPG" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/alipay.JPG" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/09/05/bug/dockerfile-jdk-version/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/jdk.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">运维手册——Dockerfile的JDK版本更换</div></div></a></div><div class="next-post pull_right"><a href="/2020/08/28/gpu/nvidia-install/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/nvidia.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Centos7安装NVIDIA显卡驱动和CUDA以及Docker-GPU环境</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/09/23/bug/redis.migrate-rds/" title="运维手册——Redis迁云问题总结"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/redis.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-09-23</div><div class="relatedPosts_title">运维手册——Redis迁云问题总结</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/16/aws/aws-redis-migrate/" title="迁移自建Redis至AWS的ElastiCache For Redis"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/redis.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-09-18</div><div class="relatedPosts_title">迁移自建Redis至AWS的ElastiCache For Redis</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/27/docker/docker-install-db/" title="Docker安装Mysql、Mongodb、Redis及数据迁移"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-08-20</div><div class="relatedPosts_title">Docker安装Mysql、Mongodb、Redis及数据迁移</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/gh/xaoxuu/volantis/js/volantis.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'GkD8YSRxxCgXoW6LqFO3cKhd-gzGzoHsz',
  appKey: 'DbbNrHwsCuK9Ehh2wgOw6UXL',
  placeholder: '记得留下你的昵称和邮箱...可以快速收到回复哦',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/redis.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Rugod</div><div class="footer_custom_text">弱小的人才习惯嘲讽和否定，而内心强大的人从不吝啬赞美和鼓励</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="255,0,0" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script></body></html>