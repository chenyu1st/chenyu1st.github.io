<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>深入浅出Docker原理及实战(三)——制作Dockerfile | 宇神之息</title><meta name="description" content="深入浅出Docker原理及实战"><meta name="keywords" content="Dockerfile,Docker,Linux,Devops,容器"><meta name="author" content="Rugod"><meta name="copyright" content="Rugod"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="crossorigin"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="深入浅出Docker原理及实战(三)——制作Dockerfile"><meta name="twitter:description" content="深入浅出Docker原理及实战"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg"><meta property="og:type" content="article"><meta property="og:title" content="深入浅出Docker原理及实战(三)——制作Dockerfile"><meta property="og:url" content="https://rugod.com/2020/06/27/docker/docker-idea-3/"><meta property="og:site_name" content="宇神之息"><meta property="og:description" content="深入浅出Docker原理及实战"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://rugod.com/2020/06/27/docker/docker-idea-3/"><link rel="prev" title="Webhooks自动部署博客" href="https://rugod.com/2020/06/28/devops/devops-webhooks/"><link rel="next" title="Helm简介及阿里云安装部署" href="https://rugod.com/2020/06/21/helm/helm-install/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a29fc1f2b32c6a60aee5dbf412c89285";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-164950732-1', 'auto');
ga('send', 'pageview');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://www.rugod.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Rugod","link":"链接: ","source":"来源: 宇神之息","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"宇神,牛逼","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/Challenger.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">58</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">68</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于本人</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Dockerfile简介"><span class="toc-number">1.</span> <span class="toc-text">Dockerfile简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#制作Dockfile"><span class="toc-number">2.</span> <span class="toc-text">制作Dockfile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BuildKit"><span class="toc-number">2.1.</span> <span class="toc-text">BuildKit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockfile格式"><span class="toc-number">2.2.</span> <span class="toc-text">Dockfile格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile指令"><span class="toc-number">2.3.</span> <span class="toc-text">Dockerfile指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解析器指令"><span class="toc-number">2.3.1.</span> <span class="toc-text">解析器指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Environment-replacement"><span class="toc-number">2.3.2.</span> <span class="toc-text">Environment replacement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FROM"><span class="toc-number">2.3.3.</span> <span class="toc-text">FROM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RUN"><span class="toc-number">2.3.4.</span> <span class="toc-text">RUN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMD"><span class="toc-number">2.3.5.</span> <span class="toc-text">CMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LABEL"><span class="toc-number">2.3.6.</span> <span class="toc-text">LABEL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXPOSE"><span class="toc-number">2.3.7.</span> <span class="toc-text">EXPOSE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ENV"><span class="toc-number">2.3.8.</span> <span class="toc-text">ENV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADD"><span class="toc-number">2.3.9.</span> <span class="toc-text">ADD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#COPY"><span class="toc-number">2.3.10.</span> <span class="toc-text">COPY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ENTRYPOINT"><span class="toc-number">2.3.11.</span> <span class="toc-text">ENTRYPOINT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VOLUME"><span class="toc-number">2.3.12.</span> <span class="toc-text">VOLUME</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WORKDIR"><span class="toc-number">2.3.13.</span> <span class="toc-text">WORKDIR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARG"><span class="toc-number">2.3.14.</span> <span class="toc-text">ARG</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相似指令对比"><span class="toc-number">2.4.</span> <span class="toc-text">相似指令对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RUN-and-CMD"><span class="toc-number">2.4.1.</span> <span class="toc-text">RUN and CMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#COPY-and-ADD"><span class="toc-number">2.4.2.</span> <span class="toc-text">COPY and ADD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ENTRYPOINT-and-CMD组合执行的命令"><span class="toc-number">2.4.3.</span> <span class="toc-text">ENTRYPOINT and CMD组合执行的命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考文献"><span class="toc-number">4.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">宇神之息</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于本人</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">深入浅出Docker原理及实战(三)——制作Dockerfile</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-27 22:55:44"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-27</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-30 16:08:34"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-30</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Docker/">Docker</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">6.8k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 25 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/06/27/docker/docker-idea-3/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/06/27/docker/docker-idea-3/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>声明:这是我在大学毕业后进入第一家互联网公司学习的内容</p>
<hr>
<p>深入浅出Docker原理及实战系列第三篇，我主要分享如何制作一个Dockerfile，以及基本命令格式。</p>
<h1 id="Dockerfile简介"><a href="#Dockerfile简介" class="headerlink" title="Dockerfile简介"></a>Dockerfile简介</h1><p>Docker可以通过阅读Dockerfile的指令来自动构建镜像。 Dockerfile是一个文本文件，其中包含用户可以在命令行上调用组装镜像的所有命令。使用docker build命令可以创建自动构建流程，该构建连续执行多个命令行指令。</p>
<h1 id="制作Dockfile"><a href="#制作Dockfile" class="headerlink" title="制作Dockfile"></a>制作Dockfile</h1><p>Docker镜像由只读层组成，每个只读层代表一条Dockerfile指令。这些层是堆叠的，每个层都是上一层的变化的增量。下面是一个Dockerfile的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">COPY . &#x2F;app</span><br><span class="line">RUN make &#x2F;app</span><br><span class="line">CMD python &#x2F;app&#x2F;app.py</span><br></pre></td></tr></table></figure>

<p>每条指令创建一层：</p>
<ul>
<li>FROM：基于ubuntu:18.04的镜像创建一个只读层。</li>
<li>COPY：从Docker客户端的当前目录添加文件。</li>
<li>RUN： 使用make构建应用程序</li>
<li>CMD： 指定在容器中运行什么命令。</li>
</ul>
<p>运行镜像并生成容器时，可以在基础层之上添加一个新的可写层（“容器层”）。对运行中的容器所做的所有更改（例如写入新文件，修改现有文件和删除文件）都将写入可写容器层。</p>
<h2 id="BuildKit"><a href="#BuildKit" class="headerlink" title="BuildKit"></a>BuildKit</h2><p>从版本18.09开始，Docker支持由moby / buildkit 项目提供的用于执行构建的新后端。与旧的实现相比，BuildKit后端提供了许多好处。例如，BuildKit可以：</p>
<ul>
<li>检测并跳过执行未使用的构建阶段</li>
<li>并行构建独立构建阶段</li>
<li>两次构建之间仅增量传输构建上下文中的已更改文件</li>
<li>在构建上下文中检测并跳过未使用的文件的传输</li>
<li>使用具有许多新功能的外部Dockerfile实现</li>
<li>避免与其他API产生副作用（中间图像和容器）</li>
<li>优先考虑构建缓存以进行自动修剪</li>
<li>要使用BuildKit后端，您需要DOCKER_BUILDKIT=1在CLI上设置环境变量 ，然后再调用docker build。</li>
</ul>
<p>要了解基于BuildKit的构建可用的实验性Dockerfile语法，<a href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md" target="_blank" rel="noopener">请参阅BuildKit存储库中的文档</a>。</p>
<p>注意！目前我还没有太了解这个功能，而且项目中dockerfile都没有引入，所以对于该功能不做深入了解。</p>
<h2 id="Dockfile格式"><a href="#Dockfile格式" class="headerlink" title="Dockfile格式"></a>Dockfile格式</h2><p>文件的指令不区分大小写。但是，约定是大写，以便更轻松地将它们与参数区分开。</p>
<p>Docker按顺序在Dockerfile中运行指令，Dockerfile必须以“FROM”指令开头。这可能在解析器指令，注释和全局范围的ARG之后。</p>
<p>FROM指令指定要从上一层镜像中构建。</p>
<p>FROM只能前面有一个或多个ARG指令，这些指令声明Dockerfile中FROM行中使用的参数</p>
<p>Docker会将以＃开头的行视为注释，除非该行是有效的解析器指令。</p>
<p>注释中不支持换行符。</p>
<h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><p>在Dockerfile中，每一条语句都是一个指令。</p>
<p>Dockerfile有以下指令列表：</p>
<table>
<thead>
<tr>
<th>部分</th>
<th>指令</th>
</tr>
</thead>
<tbody><tr>
<td>基础镜像信息</td>
<td>FROM</td>
</tr>
<tr>
<td>镜像操作指令</td>
<td>RUN、COPY、ADD、EXPOSE、WORKDIR、VOLUME等</td>
</tr>
<tr>
<td>容器启动时执行指令</td>
<td>CMD、ENTRYPOINT</td>
</tr>
</tbody></table>
<h3 id="解析器指令"><a href="#解析器指令" class="headerlink" title="解析器指令"></a>解析器指令</h3><p>解析器指令是可选的，并且会影响Dockerfile处理后续行的方式。解析器指令不会在构建中添加图层，也不会显示为构建步骤。解析器指令以形式写为特殊类型的注释# directive=value。单个指令只能使用一次。</p>
<p>支持以下解析器指令：</p>
<ul>
<li>syntax</li>
<li>escape</li>
</ul>
<p>syntax仅当使用BuildKit后端时才启用此功能，我还没有用BuildKit，所以到在此不讲。</p>
<p>escape写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># escape&#x3D;\</span><br></pre></td></tr></table></figure>

<p>该escape指令设置用来逃避的字符的字符 Dockerfile。如果未指定，则默认转义字符为\。</p>
<p>转义字符用于转义一行中的字符和转义换行符。这允许一条Dockerfile指令跨越多行。请注意，无论escape是否包含在Dockerfile，都不会在RUN命令中执行转义，除非在行末。</p>
<p>将转义符设置为`对Windows下尤其有用 ，其中目录路径分隔符为\。</p>
<p>一个简单的演示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">如果不加escape指令</span><br><span class="line"></span><br><span class="line">FROM microsoft&#x2F;nanoserver</span><br><span class="line">COPY testfile.txt c:\\</span><br><span class="line">RUN dir c:\</span><br><span class="line"></span><br><span class="line">PS C:\John&gt; docker build -t cmd .</span><br><span class="line">Sending build context to Docker daemon 3.072 kB</span><br><span class="line">Step 1&#x2F;2 : FROM microsoft&#x2F;nanoserver</span><br><span class="line"> ---&gt; 22738ff49c6d</span><br><span class="line">Step 2&#x2F;2 : COPY testfile.txt c:\RUN dir c:</span><br><span class="line">GetFileAttributesEx c:RUN: The system cannot find the file specified.</span><br><span class="line">PS C:\John&gt;</span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line">加了escape指令后</span><br><span class="line"></span><br><span class="line"># escape&#x3D;&#96;</span><br><span class="line"></span><br><span class="line">FROM microsoft&#x2F;nanoserver</span><br><span class="line">COPY testfile.txt c:\</span><br><span class="line">RUN dir c:\</span><br><span class="line"></span><br><span class="line">PS C:\John&gt; docker build -t succeeds --no-cache&#x3D;true .</span><br><span class="line">Sending build context to Docker daemon 3.072 kB</span><br><span class="line">Step 1&#x2F;3 : FROM microsoft&#x2F;nanoserver</span><br><span class="line"> ---&gt; 22738ff49c6d</span><br><span class="line">Step 2&#x2F;3 : COPY testfile.txt c:\</span><br><span class="line"> ---&gt; 96655de338de</span><br><span class="line">Removing intermediate container 4db9acbb1682</span><br><span class="line">Step 3&#x2F;3 : RUN dir c:\</span><br><span class="line"> ---&gt; Running in a2c157f842f5</span><br><span class="line"> Volume in drive C has no label.</span><br><span class="line"> Volume Serial Number is 7E6D-E0F7</span><br><span class="line"></span><br><span class="line"> Directory of c:\</span><br><span class="line"></span><br><span class="line">10&#x2F;05&#x2F;2016  05:04 PM             1,894 License.txt</span><br><span class="line">10&#x2F;05&#x2F;2016  02:22 PM    &lt;DIR&gt;          Program Files</span><br><span class="line">10&#x2F;05&#x2F;2016  02:14 PM    &lt;DIR&gt;          Program Files (x86)</span><br><span class="line">10&#x2F;28&#x2F;2016  11:18 AM                62 testfile.txt</span><br><span class="line">10&#x2F;28&#x2F;2016  11:20 AM    &lt;DIR&gt;          Users</span><br><span class="line">10&#x2F;28&#x2F;2016  11:20 AM    &lt;DIR&gt;          Windows</span><br><span class="line">           2 File(s)          1,956 bytes</span><br><span class="line">           4 Dir(s)  21,259,096,064 bytes free</span><br><span class="line"> ---&gt; 01c7f3bef04f</span><br><span class="line">Removing intermediate container a2c157f842f5</span><br><span class="line">Successfully built 01c7f3bef04f</span><br><span class="line">PS C:\John&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Environment-replacement"><a href="#Environment-replacement" class="headerlink" title="Environment replacement"></a>Environment replacement</h3><p>环境变量（与ENV的声明），也可以在特定指令作为变量用来被解释 Dockerfile。转义也可以通过将类变量的语法包括在语句中而得到处理。</p>
<p>Dockerfile用 $variable_name或${variable_name}表示环境变量。它们被等效地对待，并且大括号语法通常用于解决变量名没有空格的问题，例如${foo}_bar</p>
<p>该${variable_name}语法还支持一些标准bash 修饰符，如下所示：</p>
<ul>
<li>${variable:-word}表示如果variable设置，则结果将是该值。如果variable未设置，则为word结果。</li>
<li>${variable:+word}指示如果variable设置了if，则将为word结果，否则结果为空字符串。</li>
</ul>
<p>在所有情况下，word都可以是任何字符串，包括其他环境变量。</p>
<p>可通过在变量前添加\来进行转义：例如，$foo或${foo}将分别转换为$foo和${foo}文字。</p>
<p>示例（解析的表示形式显示在之后#）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ENV foo &#x2F;bar</span><br><span class="line">WORKDIR $&#123;foo&#125;   # WORKDIR &#x2F;bar</span><br><span class="line">ADD . $foo       # ADD . &#x2F;bar</span><br><span class="line">COPY \$foo &#x2F;quux # COPY $foo &#x2F;quux</span><br></pre></td></tr></table></figure>

<p>在一条指令中，环境变量替换将对每个变量使用相同的值。</p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV abc&#x3D;hello</span><br><span class="line">ENV abc&#x3D;bye def&#x3D;$abc hjk&#x3D;$abc  #def&#x3D;hello  hjk&#x3D;hello</span><br><span class="line">ENV ghi&#x3D;$abc                   #ghi&#x3D;bye</span><br></pre></td></tr></table></figure>
<p>例子中def值为hello，而不是bye。但是， ghi=bye,因为它不是设置abc=bye这一指令的一部分。</p>
<h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM [--platform&#x3D;&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</span><br><span class="line">FROM [--platform&#x3D;&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br><span class="line">FROM [--platform&#x3D;&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>
<p>FROM指令初始化一个新的构建阶段，并为后续指令设置基本镜像。<br>因此，有效的Dockerfile必须以FROM指令开头。FROM的镜像可以是任何本地可以访问到仓库里的镜像-从公共存储库（docker hub）中拉出镜像特别容易启动。</p>
<p>其中注意以下5点：</p>
<ul>
<li>ARG是先于FROM之前。</li>
<li>一个Dockerfile可以出现多次FROM以创建多个镜像，也可以将一个构建阶段作为对另一个构建阶段的依赖。只需在每个新FROM指令之前记录一次提交输出的最后一个镜像ID。每个FROM指令清除由先前指令创建的任何状态。</li>
<li>通过将AS <name> 添加到FROM指令中，可以选择为新的构建阶段指定名称。该名称可以在后续版本FROM和 COPY –from=&lt;name|index&gt;说明中使用，以引用此阶段中构建的镜像。</li>
<li>该tag或digest值是可选的。如果两个都不选择，那么缺省情况下构建器将采用latest标签。如果构建器找不到该tag值，则返回错误。</li>
<li>–platform在FROM引用多平台镜像的情况下，可选标志可用于指定镜像的平台。例如，linux/amd64， linux/arm64，或windows/amd64。默认情况下，使用构建请求的目标平台（即本机）。</li>
</ul>
<p>了解ARG和FROM之间的交互方式</p>
<p>FROM支持由出现在第一个FROM之前的任何ARG指令声明的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ARG  CODE_VERSION&#x3D;latest</span><br><span class="line">FROM base:$&#123;CODE_VERSION&#125;   #base:latest</span><br><span class="line">CMD  &#x2F;code&#x2F;run-app</span><br><span class="line"></span><br><span class="line">FROM extras:$&#123;CODE_VERSION&#125; #base:latest</span><br><span class="line">CMD  &#x2F;code&#x2F;run-extras</span><br></pre></td></tr></table></figure>
<p>在FROM之前声明的ARG在构建阶段之外，因此不能在FROM之后的任何指令中使用ARG的变量，如果要使用在第一个FROM之前声明的ARG的值，请使用ARG指令再次声明变量即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARG VERSION&#x3D;latest</span><br><span class="line">FROM busybox:$VERSION</span><br><span class="line">ARG VERSION</span><br><span class="line">RUN echo $VERSION &gt; image_version</span><br></pre></td></tr></table></figure>

<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>RUN有2种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt; (shell形式,命令在shell中运行,默认情况下在Linux是&#x2F;bin&#x2F;sh -c)</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (执行列表)</span><br></pre></td></tr></table></figure>
<p>该RUN指令将在当前镜像上方的新层中执行任何命令，并提交结果。生成的提交镜像将用于下一步的Dockerfile。</p>
<p>分层RUN指令和生成提交符合Docker的核心概念，在这些概念上，提交很方便，并且可以从映像历史记录的任何位置创建容器，就像源代码控制一样。</p>
<p>exec形式可以避免破坏shell字符串，并使用不包含指定shell可执行文件的基本映像运行RUN命令(例如bash)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在shell形式中，可以使用\将一条RUN指令继续到下一行。</span><br><span class="line">RUN &#x2F;bin&#x2F;bash -c &#39;source $HOME&#x2F;.bashrc; \</span><br><span class="line">echo $HOME&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">它们合在一起相当于以下一行：</span><br><span class="line">RUN &#x2F;bin&#x2F;bash -c &#39;source $HOME&#x2F;.bashrc; echo $HOME&#39;</span><br><span class="line"></span><br><span class="line">要使用&#39;&#x2F; bin &#x2F; sh&#39;以外的其他shell，请使用exec形式传入所需的shell。例如：</span><br><span class="line"></span><br><span class="line">RUN [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</span><br></pre></td></tr></table></figure>

<hr>
<p>注意</p>
<p>exec表单被解析为JSON数组，这意味着必须在单词周围使用双引号（”）而非单引号（’）</p>
<p>RUN在一次构建期间，指令缓存不会自动失效。比如 RUN yum install -y vim 将在下一个构建中重用。RUN指令的缓存可以通过使用–no-cache 标志来使无效,例如docker build –no-cache。还可以由ADD和COPY指令来使无效。</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD有三种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]（exec形式，这是首选形式）</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;]（作为ENTRYPOINT的默认参数）</span><br><span class="line">CMD command （shell形式）</span><br></pre></td></tr></table></figure>
<p>CMD主要目的是为执行中的容器提供默认值。这些默认值可以包含一个可执行文件，也可以忽略该可执行文件，在这种情况下，您还必须指定一条ENTRYPOINT 指令。</p>
<p>注意！！！一个Dockerfile只能一个CMD指令。如果出现多个CMD 则只有最后一个CMD才会生效。</p>
<p>与shell形式不同，exec形式不会调用命令shell。这意味着不会进行常规的shell处理。例如， CMD [ “echo”, “$HOME” ]将不会对进行变量替换$HOME。如果要进行shell处理，则可以使用shell形式或直接执行shell，例如：CMD [ “sh”, “-c”, “echo $HOME” ]</p>
<p>如果CMD使用的shell形式，则将在中<command>执行 /bin/sh -c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">CMD echo &quot;This is a test.&quot; | wc -</span><br></pre></td></tr></table></figure>

<p>如果要在没有shell的情况下运行 <command> ，则必须将命令表示为JSON数组，并提供可执行文件的完整路径。 此数组形式是的首选格式CMD。任何其他参数必须在数组中分别表示为字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">CMD [&quot;&#x2F;usr&#x2F;bin&#x2F;wc&quot;,&quot;--help&quot;]</span><br></pre></td></tr></table></figure>

<p>如果希望容器每次都运行相同的可执行文件，则应考虑ENTRYPOINT与CMD结合使用</p>
<p>如果docker run指定了参数，则它们将覆盖中指定的CMD默认参数。</p>
<p>最后重申一点CMD和RUN的区别：RUN实际上运行命令并提交结果；CMD在构建时不执行任何操作，而是在镜像启动后执行命令。</p>
<h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;&#x3D;&lt;value&gt; &lt;key&gt;&#x3D;&lt;value&gt; &lt;key&gt;&#x3D;&lt;value&gt; ...</span><br></pre></td></tr></table></figure>
<p>该LABEL指令将元数据添加到镜像。一个LABEL是键值对。如果要在LABEL值中包含空格，请像在命令行分析中一样使用引号和反斜杠。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LABEL &quot;com.example.vendor&quot;&#x3D;&quot;ACME Incorporated&quot;</span><br><span class="line">LABEL com.example.label-with-value&#x3D;&quot;foo&quot;</span><br><span class="line">LABEL version&#x3D;&quot;1.0&quot;</span><br><span class="line">LABEL description&#x3D;&quot;This text illustrates \</span><br><span class="line">that label-values can span multiple lines.&quot;</span><br></pre></td></tr></table></figure>

<p>一个镜像可以有多个标签。您可以在一行上指定多个标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LABEL multi.label1&#x3D;&quot;value1&quot; multi.label2&#x3D;&quot;value2&quot; other&#x3D;&quot;value3&quot;</span><br><span class="line">LABEL multi.label1&#x3D;&quot;value1&quot; \</span><br><span class="line">      multi.label2&#x3D;&quot;value2&quot; \</span><br><span class="line">      other&#x3D;&quot;value3&quot;</span><br></pre></td></tr></table></figure>
<p>基础镜像（FROM中的镜像）中包含的标签会被后面的镜像继承。如果标签已经存在但具有不同的值，则最近应用的值将覆盖任何先前设置的值。</p>
<p>要查看镜像的标签，请使用docker image inspect命令。可以使用该–format选项仅显示标签。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect --format&#x3D;&#39;&#39; myimage</span><br><span class="line">&#123;</span><br><span class="line">  &quot;com.example.vendor&quot;: &quot;ACME Incorporated&quot;,</span><br><span class="line">  &quot;com.example.label-with-value&quot;: &quot;foo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;This text illustrates that label-values can span multiple lines.&quot;,</span><br><span class="line">  &quot;multi.label1&quot;: &quot;value1&quot;,</span><br><span class="line">  &quot;multi.label2&quot;: &quot;value2&quot;,</span><br><span class="line">  &quot;other&quot;: &quot;value3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;&#x2F;&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure>
<p>EXPOSE指令通知Docker容器在运行时监听指定的网络端口。您可以指定端口是侦听TCP还是UDP，如果未指定协议，则默认值为TCP。</p>
<p>EXPOSE指令实际上并未发布端口。它充当构建映像的人员和运行容器的人员之间的一种文档类型，有关打算发布哪些端口的信息。要在运行容器时实际发布端口，请使用-p标记在docker run 发布和映射一个或多个端口，或者使用-P标记发布所有公开的端口并将它们映射到高阶端口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">默认情况下，EXPOSE指定的是TCP</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">指定UDP</span><br><span class="line">EXPOSE 80&#x2F;udp</span><br><span class="line"></span><br><span class="line">同时在TCP和UDP上公开</span><br><span class="line">EXPOSE 80&#x2F;tcp</span><br><span class="line">EXPOSE 80&#x2F;udp</span><br><span class="line"></span><br><span class="line">在这种情况下，docker run -p，则该端口仅对TCP公开一次，对于UDP公开一次。</span><br><span class="line">-p的端口在主机上使用临时的高阶主机端口，因此该端口对于TCP和UDP将是不同的。</span><br><span class="line"></span><br><span class="line">无论EXPOSE设置如何，都可以在运行时使用该-p标志覆盖它们。例如</span><br><span class="line">docker run -p 80:80&#x2F;tcp -p 80:80&#x2F;udp</span><br></pre></td></tr></table></figure>

<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;&#x3D;&lt;value&gt;</span><br></pre></td></tr></table></figure>
<p>ENV指令将环境变量<key>设置为<value>。此值将在构建阶段中所有后续指令的环境中使用，并且支持Environment replacement</p>
<p>ENV指令有两种形式。</p>
<p>第一种形式ENV <key> <value>会将一个变量设置为一个值。第一个空格之后的整个字符串将被视为<value>-包括空格字符。该值将为其他环境变量解释，因此如果不对引号字符进行转义，则将其删除。</p>
<p>第二种形式ENV <key>=<value> 允许一次设置多个变量。请注意，第二种形式在语法中使用等号（=），而第一种形式则不使用等号（=）。像命令行解析一样，引号和反斜杠可用于在值中包含空格。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ENV myName&#x3D;&quot;John Doe&quot; myDog&#x3D;Rex\ The\ Dog \</span><br><span class="line">    myCat&#x3D;fluffy</span><br><span class="line">和</span><br><span class="line">ENV myName John Doe</span><br><span class="line">ENV myDog Rex The Dog</span><br><span class="line">ENV myCat fluffy</span><br><span class="line"></span><br><span class="line">将在最终镜像中产生相同的效果</span><br></pre></td></tr></table></figure>
<p>在运行容器时，使用设置的环境变量将保留。可以使用docker inspect查看ENV的值，并使用更改它们docker run –env <key>=<value></p>
<p>注意！！！环境变量的持久性可能导致意外的副作用，如果要为单个命令设置值，只需要RUN <key>=<value> <command> 即可让command里使用key</p>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD [--chown&#x3D;&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">ADD [--chown&#x3D;&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure>
<p>ADD从目录或远程文件URL <src>中复制新文件， ，并将它们添加到镜像文件系统中的路径<dest>。</p>
<p>可以指定多个<src>资源，但是如果它们是文件或目录，则将其路径解释为相对于构建上下文源的路径。每个都<src>可能包含通配符，并且匹配将使用Go的 <a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="noopener">filepath.Match</a>规则完成</p>
<p>除非选择–chown标志指定给定的用户名，组名或UID / GID组合以请求对所添加内容的特定所有权，否则所有新文件和目录的UID和GID均为0。–chown标志的格式允许用户名和组名字符串或直接整数UID和GID任意组合。提供不带组名的用户名或不带GID的UID将使用与GID相同的数字UID。如果提供了用户名或组名，则将使用容器的根文件系统 /etc/passwd和/etc/group文件将名称分别转换为整数UID或GID。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 要添加所有以“hom”开头的文件：</span><br><span class="line">ADD hom?.txt &#x2F;mydir&#x2F;</span><br><span class="line"></span><br><span class="line"># 使用相对路径，并将“test.txt”添加到&lt;WORKDIR&gt;&#x2F;relativeDir&#x2F;</span><br><span class="line">ADD test.txt relativeDir&#x2F;</span><br><span class="line"></span><br><span class="line">ADD --chown&#x3D;55:mygroup files* &#x2F;somedir&#x2F;</span><br><span class="line"></span><br><span class="line">ADD --chown&#x3D;bin files* &#x2F;somedir&#x2F;</span><br></pre></td></tr></table></figure>

<p>注意！！！如果<src>的内容已更改，则遇到的第一个ADD指令将使Dockerfile中所有后续指令的缓存无效。这包括使高速缓存中的RUN指令无效。</p>
<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY [--chown&#x3D;&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY [--chown&#x3D;&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure>

<p>COPY从<src>复制新文件或目录，并将它们添加到容器的文件系统中，路径为<dest>。</p>
<p>可以指定多个<src>资源，但是文件和目录的路径将被解释为相对于构建上下文的来源。</p>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#EXEC的形式，这是优选的形式：</span><br><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br><span class="line">#Shell的形式</span><br><span class="line">ENTRYPOINT command param1 param2</span><br></pre></td></tr></table></figure>
<p>ENTRYPOINT可以作为可执行文件运行的容器的配置，一般配合CMD使用。 </p>
<p>指定 ENTRYPOINT 为 exec 形式时，命令行上指定的参数会作为参数添加到 ENTRYPOINT 的参数列表中。</p>
<p>可以使用exec形式的ENTRYPOINT来设置相当稳定的默认命令和参数，然后使用两种形式的CMD来设置更可能被更改的其他默认值。</p>
<p>例如：</p>
<ul>
<li><p>EXEC形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]</span><br><span class="line">CMD [&quot;-c&quot;]</span><br><span class="line"></span><br><span class="line">docker build -t test:1.0 .</span><br><span class="line"></span><br><span class="line">docker run -it --rm --name test test:1.0 </span><br><span class="line"></span><br><span class="line">Mem: 1704520K used, 352148K free, 0K shrd, 0K buff, 140368121167873K cached</span><br><span class="line">CPU:   5% usr   0% sys   0% nic  94% idle   0% io   0% irq   0% sirq</span><br><span class="line">Load average: 0.08 0.03 0.05 2&#x2F;98 6</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class="line">    1     0 root     R     3164   0%   0% top -b -c </span><br><span class="line">    </span><br><span class="line">结果执行的是top -b </span><br><span class="line"></span><br><span class="line">docker run -it --rm --name test  test:1.0  -H</span><br><span class="line"></span><br><span class="line">top - 08:25:00 up  7:27,  0 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Threads:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem:   2056668 total,  1616832 used,   439836 free,    99352 buffers</span><br><span class="line">KiB Swap:  1441840 total,        0 used,  1441840 free.  1324440 cached Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    1 root      20   0   19744   2336   2080 R  0.0  0.1   0:00.04 top -b -H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果是执行top -b -H</span><br></pre></td></tr></table></figure>
</li>
<li><p>Shell形式</p>
</li>
</ul>
<p>shell形式可以为ENTRYPOINT指定一个纯字符串，它将在中执行/bin/sh -c。这种形式将使用shell处理来替代shell环境变量，并且将忽略任何CMD或docker run命令行参数。为了确保能够正确docker stop发出任何长期运行的ENTRYPOINT可执行文件信号，需要以下exec启动它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT exec top -b</span><br><span class="line"></span><br><span class="line">docker build -t test:1.0 .</span><br><span class="line"></span><br><span class="line">docker run -it --rm --name test test:1.0</span><br><span class="line"></span><br><span class="line">Mem: 1704520K used, 352148K free, 0K shrd, 0K buff, 140368121167873K cached</span><br><span class="line">CPU:   5% usr   0% sys   0% nic  94% idle   0% io   0% irq   0% sirq</span><br><span class="line">Load average: 0.08 0.03 0.05 2&#x2F;98 6</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class="line">    1     0 root     R     3164   0%   0% top -b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果忘记添加exec到开头的ENTRYPOINT中</span><br><span class="line"></span><br><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT top -b</span><br><span class="line">CMD -H</span><br><span class="line"></span><br><span class="line">docker build -t test:1.0 .</span><br><span class="line"></span><br><span class="line">docker run -it --name test test:1.0 -c </span><br><span class="line"></span><br><span class="line">Mem: 1704184K used, 352484K free, 0K shrd, 0K buff, 140621524238337K cached</span><br><span class="line">CPU:   9% usr   2% sys   0% nic  88% idle   0% io   0% irq   0% sirq</span><br><span class="line">Load average: 0.01 0.02 0.05 2&#x2F;101 7</span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.4  0.0   2612   604 pts&#x2F;0    Ss+  09:16   0:00 &#x2F;bin&#x2F;sh -c top</span><br><span class="line">root          6  0.0  0.0   5956  3324 pts&#x2F;0    S+   09:16   0:00 top -b</span><br><span class="line">    </span><br><span class="line">从输出中可以看到top，指定ENTRYPOINT的不是PID 1,而且CMD中的参数-H无效,docker run带的-c参数也无效</span><br></pre></td></tr></table></figure>

<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;&#x2F;data&quot;]</span><br></pre></td></tr></table></figure>

<p>VOLUME指令创建具有指定名称的挂载点，并将其标记为保存本机或其他容器的外部安装的存储卷。</p>
<p>例子：</p>
<p>docker run命令使用基础镜像内指定位置上存在的任何数据初始化新创建的卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN mkdir &#x2F;myvol</span><br><span class="line">RUN echo &quot;hello world&quot; &gt; &#x2F;myvol&#x2F;greeting</span><br><span class="line">VOLUME &#x2F;myvol</span><br></pre></td></tr></table></figure>
<p>Dockerfile生成一个镜像，docker run会创建一个新的挂载点/myvol并将该greeting文件复制 到新创建的卷中。</p>
<p>如果删除容器里的greeting，然后重启容器，该文件仍然被删除</p>
<p>但是如果删除容器里的greeting并且再删除容器，再创建一个新的容器，该文件则存在，因为实际上又执行了dockerfile里的RUN echo “hello world” &gt; /myvol/greeting 命令</p>
<p>注意点</p>
<ul>
<li>主机目录是在容器运行时声明的：主机目录（挂载点）本质上是依赖于主机的。这是为了保留镜像的可移植性，因为不能保证给定的主机目录在所有主机上都可用。因此无法从Dockerfile内挂载主机目录。</li>
<li>从Dockerfile中更改卷：如果在声明了卷之后有任何构建步骤更改了卷中的数据，则这些更改的指令将无效。</li>
</ul>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR &#x2F;path&#x2F;to&#x2F;workdir</span><br></pre></td></tr></table></figure>
<p>WORKDIR会设置工作目录并成为后续Dockerfile里的RUN, CMD, ENTRYPOINT, COPY 和 ADD 的当前路径，如果WORKDIR不存在，即使以后的Dockerfile指令中未使用它也将被创建。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR &#x2F;a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>
<p>最后pwd的路径为 /a/b/c</p>
<p>WORKDIR能解析在此之前ENV设置的环境变量，而且只能使用Dockerfile中显示的环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV DIRPATH &#x2F;path</span><br><span class="line">WORKDIR $DIRPATH&#x2F;$DIRNAME</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>

<p>最后pwd的路径为 /path/$DIRNAME</p>
<h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;[&#x3D;&lt;default value&gt;]</span><br></pre></td></tr></table></figure>
<p>该ARG指令定义了一个变量，用户可以在构建时docker build使用带有–build-arg <varname>=<value> 标志的命令将其传递给构建器。如果用户指定了未在Dockerfile中定义的构建参数，则构建会输出警告。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ARG user1&#x3D;someuser</span><br><span class="line">ARG buildno&#x3D;1</span><br></pre></td></tr></table></figure>
<p>如果ARG具有默认值，并且在构建时未传递任何值，那么构建器将使用默认值。即user1=someuser、buildno=1</p>
<p>一个ARG变量定义只能在Dockerfile构建的一个阶段内的那一行到结束范围内生效，简而言之就是ARG声明的那一刻到下一个FROM中间有效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">RUN echo SETTINGS</span><br><span class="line">ARG SETTINGS</span><br><span class="line">RUN .&#x2F;run&#x2F;setup $SETTINGS</span><br><span class="line"></span><br><span class="line">FROM busybox</span><br><span class="line">RUN echo SETTINGS</span><br><span class="line">ARG SETTINGS</span><br><span class="line">RUN .&#x2F;run&#x2F;other $SETTINGS</span><br><span class="line"></span><br><span class="line">docker build --build-arg SETTINGS&#x3D;hello .</span><br><span class="line"></span><br><span class="line">执行结果为：</span><br><span class="line">第一阶段的FROM过程</span><br><span class="line">RUN echo SETTINGS</span><br><span class="line">ARG hello</span><br><span class="line">RUN .&#x2F;run&#x2F;setup hello</span><br><span class="line"></span><br><span class="line">第二阶段的FROM过程</span><br><span class="line">RUN echo SETTINGS</span><br><span class="line">ARG hello</span><br><span class="line">RUN .&#x2F;run&#x2F;other hello</span><br></pre></td></tr></table></figure>
<p>ARG在它被定义的构建阶段范围进行。要在多个阶段使用ARG，每个阶段都必须包含ARG指令。</p>
<p>ARG或ENV会指定RUN指令可用的变量。使用ENV指令定义的环境变量 始终会覆盖ARG同名指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ARG CONT_IMG_VER</span><br><span class="line">ENV CONT_IMG_VER v1.0.0</span><br><span class="line">RUN echo $CONT_IMG_VER</span><br><span class="line"></span><br><span class="line">docker build --build-arg CONT_IMG_VER&#x3D;v2.0.1 .</span><br></pre></td></tr></table></figure>
<p>在这种情况下，该RUN指令将使用v1.0.0而不是用户传递的ARG：v2.0.1。此行为类似于Shell脚本，其中局部作用域的变量从其定义的角度覆盖作为参数传递或从环境继承的变量。</p>
<p>使用上面的示例，但使用不同的ENV规范，可以在ARG和ENV指令之间创建更有用的交互：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ARG CONT_IMG_VER</span><br><span class="line">ENV CONT_IMG_VER $&#123;CONT_IMG_VER:-v1.0.0&#125;</span><br><span class="line">RUN echo $CONT_IMG_VER  &gt; &#x2F;haha</span><br><span class="line"></span><br><span class="line">docker build --build-arg CONT_IMG_VER&#x3D;v2.0.1 -t test:1.5 .</span><br><span class="line">docker run --name test --rm -itd test:1.5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker exec -it test cat &#x2F;haha</span><br><span class="line">v2.0.1</span><br></pre></td></tr></table></figure>
<p>与ARG指令不同，ENV值始终保留在生成的镜像中。使用此Dockerfile示例，CONT_IMG_VER它仍然保留在映像中，但其值将是指令第3行中的默认设置ENV,而ENV是ARG在docker bulid构建时传的参数v2.0.1 。</p>
<p>在此示例中，变量扩展技术可以从命令行传递参数，并利用ENV指令将其保留在最终映像中 。</p>
<h2 id="相似指令对比"><a href="#相似指令对比" class="headerlink" title="相似指令对比"></a>相似指令对比</h2><h3 id="RUN-and-CMD"><a href="#RUN-and-CMD" class="headerlink" title="RUN and CMD"></a>RUN and CMD</h3><p>RUN是针对镜像，在镜像构建的时候运行命令并提交结果，一个Dockerfile可以有很多个RUN命令</p>
<p>CMD是针对容器，在镜像构建的时候不执行任何操作，而是在镜像启动后执行命令，一个Dockerfile即使有很多个CMD命令，也只生效最后一个(原因在下面解释)</p>
<h3 id="COPY-and-ADD"><a href="#COPY-and-ADD" class="headerlink" title="COPY and ADD"></a>COPY and ADD</h3><p>COPY能够将构建命令所在的主机本地的文件或目录，复制到镜像文件系统。</p>
<p>ADD指令不仅能够将构建命令所在的主机本地的文件或目录，而且能够将远程URL所对应的文件或目录，作为资源复制到镜像文件系统。</p>
<p>满足同等功能的情况下，推荐使用COPY指令。ADD指令更擅长读取本地tar文件并解压缩。而且由于因为路径、资源更改而导致缓存失效的情况出现，我们更应该尽量少用ADD，而改用使用RUN wget或RUN curl替代，并且把这一步骤尽可能地放在Dockerfile的后面位置。</p>
<h3 id="ENTRYPOINT-and-CMD组合执行的命令"><a href="#ENTRYPOINT-and-CMD组合执行的命令" class="headerlink" title="ENTRYPOINT and CMD组合执行的命令"></a>ENTRYPOINT and CMD组合执行的命令</h3><ul>
<li>Dockerfile应至少指定CMD或ENTRYPOINT命令之一。</li>
<li>使用容器作为可执行文件时应定义ENTRYPOINT </li>
<li>CMD应该用作ENTRYPOINT在容器中定义命令或执行临时命令的默认参数的方式。</li>
<li>当使用其他参数运行容器时，CMD 将被覆盖。</li>
</ul>
<p>ENTRYPOINT应该被当做docker的可执行程序，CMD应该被当做ENTRYPOINT的默认参数。</p>
<p>组合列表：以df命令为例</p>
<table>
<thead>
<tr>
<th>CMD/ENTRYPOINT</th>
<th>No ENTRYPOINT</th>
<th>ENTRYPOINT du -H</th>
<th>ENTRYPOINT [“du”, “-H”]</th>
</tr>
</thead>
<tbody><tr>
<td>No CMD</td>
<td>不允许</td>
<td>/bin/sh -c du -H</td>
<td>du -H</td>
</tr>
<tr>
<td>CMD [“df”, “-h”]</td>
<td>df -h</td>
<td>/bin/sh -c du -H</td>
<td>du -H df -h</td>
</tr>
<tr>
<td>CMD [“-h”, “-T”]</td>
<td>-h -T</td>
<td>/bin/sh -c du -H</td>
<td>du -H -h -T</td>
</tr>
<tr>
<td>CMD df -h</td>
<td>/bin/sh -c df -h</td>
<td>/bin/sh -c du -H</td>
<td>du -H /bin/sh -c df -h</td>
</tr>
</tbody></table>
<ul>
<li>如果 ENTRYPOINT 使用了 shell 模式，CMD 指令会被忽略。</li>
<li>如果 ENTRYPOINT 使用了 exec 模式，CMD 指定的内容被追加为 ENTRYPOINT 指定命令的参数。</li>
</ul>
<p>结论：一起使用ENTRYPOINT和CMD时，务必同时使用两个指令的exec形式，这一点很重要。尝试使用shell形式，或者混合匹配shell和exec形式几乎不会给您想要的结果。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Dockerfile基本命令和写法格式都讲完了，下期主要讲Dockerfile的构建底层实现原理。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile官方文档参考</a></p>
<hr>
<p>版权声明：</p>
<p>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Rugod</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rugod.com/2020/06/27/docker/docker-idea-3/">https://rugod.com/2020/06/27/docker/docker-idea-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rugod.com" target="_blank">宇神之息</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Dockerfile/">Dockerfile</a><a class="post-meta__tags" href="/tags/Docker/">Docker</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Devops/">Devops</a><a class="post-meta__tags" href="/tags/%E5%AE%B9%E5%99%A8/">容器</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/ssl.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/wechat.JPG" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/alipay.JPG" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/28/devops/devops-webhooks/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/devops.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Webhooks自动部署博客</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/21/helm/helm-install/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/helm.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Helm简介及阿里云安装部署</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/29/docker/docker-idea-4/" title="深入浅出Docker原理及实战(四)——构建镜像"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-07-30</div><div class="relatedPosts_title">深入浅出Docker原理及实战(四)——构建镜像</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/24/docker/docker-idea-1/" title="深入浅出Docker原理及实战(一)——Docker的基本理念与原理"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-07-30</div><div class="relatedPosts_title">深入浅出Docker原理及实战(一)——Docker的基本理念与原理</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/09/docker/docker-idea-2/" title="深入浅出Docker原理及实战(二)——Docker的安装及常用命令"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-07-30</div><div class="relatedPosts_title">深入浅出Docker原理及实战(二)——Docker的安装及常用命令</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/gh/xaoxuu/volantis/js/volantis.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'GkD8YSRxxCgXoW6LqFO3cKhd-gzGzoHsz',
  appKey: 'DbbNrHwsCuK9Ehh2wgOw6UXL',
  placeholder: '记得留下你的昵称和邮箱...可以快速收到回复哦',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Rugod</div><div class="footer_custom_text">弱小的人才习惯嘲讽和否定，而内心强大的人从不吝啬赞美和鼓励</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="255,0,0" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script></body></html>