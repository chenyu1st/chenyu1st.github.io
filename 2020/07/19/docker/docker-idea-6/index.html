<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>深入浅出Docker原理及实战(六)——重新认识Docker容器 | 宇神之息</title><meta name="description" content="深入浅出Docker原理及实战"><meta name="keywords" content="Docker,Linux,容器"><meta name="author" content="Rugod"><meta name="copyright" content="Rugod"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="crossorigin"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="深入浅出Docker原理及实战(六)——重新认识Docker容器"><meta name="twitter:description" content="深入浅出Docker原理及实战"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg"><meta property="og:type" content="article"><meta property="og:title" content="深入浅出Docker原理及实战(六)——重新认识Docker容器"><meta property="og:url" content="https://rugod.com/2020/07/19/docker/docker-idea-6/"><meta property="og:site_name" content="宇神之息"><meta property="og:description" content="深入浅出Docker原理及实战"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://rugod.com/2020/07/19/docker/docker-idea-6/"><link rel="prev" title="运维手册——Kubernetes容器时区不同步" href="https://rugod.com/2020/07/22/bug/dockerfile-time-zone/"><link rel="next" title="Kubernetes入门篇(三)——Kubernetes的对象和API" href="https://rugod.com/2020/07/18/kubernetes/Kubernetes-introduction-3/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a29fc1f2b32c6a60aee5dbf412c89285";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-164950732-1', 'auto');
ga('send', 'pageview');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://www.rugod.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Rugod","link":"链接: ","source":"来源: 宇神之息","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"宇神,牛逼","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/Challenger.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">40</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">59</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于本人</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#进程"><span class="toc-number">1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker的底层原理"><span class="toc-number">2.</span> <span class="toc-text">Docker的底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NameSpace"><span class="toc-number">2.1.</span> <span class="toc-text">NameSpace</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#容器的第一个进程"><span class="toc-number">2.1.1.</span> <span class="toc-text">容器的第一个进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NameSpace的障眼法"><span class="toc-number">2.1.2.</span> <span class="toc-text">NameSpace的障眼法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NameSpace小结"><span class="toc-number">2.1.3.</span> <span class="toc-text">NameSpace小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cgroups"><span class="toc-number">2.2.</span> <span class="toc-text">Cgroups</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#操作Cgroups"><span class="toc-number">2.2.1.</span> <span class="toc-text">操作Cgroups</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cgroups的设计"><span class="toc-number">2.2.2.</span> <span class="toc-text">Cgroups的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cgroups小结"><span class="toc-number">2.2.3.</span> <span class="toc-text">Cgroups小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Union-File-System"><span class="toc-number">2.3.</span> <span class="toc-text">Union File System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#chroot"><span class="toc-number">2.3.1.</span> <span class="toc-text">chroot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rootfs"><span class="toc-number">2.3.2.</span> <span class="toc-text">rootfs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器的一致性"><span class="toc-number">2.3.3.</span> <span class="toc-text">容器的一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#联合文件系统（Union-File-System）到底是怎么回事"><span class="toc-number">2.3.4.</span> <span class="toc-text">联合文件系统（Union File System）到底是怎么回事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Image的底层原理"><span class="toc-number">2.3.5.</span> <span class="toc-text">Docker Image的底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个容器的组成部分"><span class="toc-number">2.3.6.</span> <span class="toc-text">一个容器的组成部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UFS小结"><span class="toc-number">2.3.7.</span> <span class="toc-text">UFS小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker存在的问题"><span class="toc-number">3.</span> <span class="toc-text">Docker存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Namespace"><span class="toc-number">3.1.</span> <span class="toc-text">Namespace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cgroups-1"><span class="toc-number">3.2.</span> <span class="toc-text">Cgroups</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UFS"><span class="toc-number">3.3.</span> <span class="toc-text">UFS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">宇神之息</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于本人</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">深入浅出Docker原理及实战(六)——重新认识Docker容器</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-19 21:14:54"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-19</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-21 11:20:31"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-21</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Docker/">Docker</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">9k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 32 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/07/19/docker/docker-idea-6/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/07/19/docker/docker-idea-6/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>声明:这是我在大学毕业后进入第一家互联网工作学习的内容</p>
<hr>
<p>深入浅出Docker原理及实战系列第六篇，我主要讲一下Docker容器的本质。</p>
<p>从进程说起。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>假如，现在你要写一个计算加法的小程序，这个程序需要的输入来自于一个文件，计算完成后的结果则输出到另一个文件中。</p>
<p>由于计算机只认识 0 和 1，所以无论用哪种语言编写这段代码，最后都需要通过某种方式翻译成二进制文件，才能在计算机操作系统中运行起来。</p>
<p>而为了能够让这些代码正常运行，我们往往还要给它提供数据，比如我们这个加法程序所需要的输入文件。这些数据加上代码本身的二进制文件，放在磁盘上，就是我们平常所说的一个“程序”，也叫代码的可执行镜像（executable image）。</p>
<p>然后，我们就可以在计算机上运行这个“程序”了。</p>
<p>首先，操作系统从“程序”中发现输入数据保存在一个文件中，所以这些数据就会被加载到内存中待命。同时，操作系统又读取到了计算加法的指令，这时，它就需要指示 CPU 完成加法操作。而 CPU 与内存协作进行加法计算，又会使用寄存器存放数值、内存堆栈保存执行的命令和变量。同时，计算机里还有被打开的文件，以及各种各样的 I/O 设备在不断地调用中修改自己的状态。</p>
<p>就这样，一旦“程序”被执行起来，它就从磁盘上的二进制文件，变成了计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。像这样一个程序运行起来后的计算机执行环境的总和，就是我们今天的主角：进程。</p>
<p>所以，对于进程来说，它的静态表现就是程序，平常都安安静静地待在磁盘上；而一旦运行起来，它就变成了计算机里的数据和状态的总和，这就是它的动态表现。</p>
<p>而容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。</p>
<h1 id="Docker的底层原理"><a href="#Docker的底层原理" class="headerlink" title="Docker的底层原理"></a>Docker的底层原理</h1><p>我们在前面讲过Docker的底层原理其实就是几个概念</p>
<ul>
<li>NameSpace 命名空间</li>
<li>Cgroups 控制组</li>
<li>Union file systems 联合文件系统</li>
<li>Container format 容器格式。</li>
</ul>
<p>对于 Docker 等大多数 Linux 容器来说，Cgroups 技术是用来制造约束的主要手段，而 Namespace 技术则是用来修改进程视图的主要方法，Union file systems 技术存放了项目(代码)启动的所有环境依赖。</p>
<h2 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h2><p>Linux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。</p>
<p>我们首先创建一个容器来试试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it busybox &#x2F;bin&#x2F;sh&#x2F;</span><br></pre></td></tr></table></figure>

<p>这个命令是 Docker 项目最重要的一个操作，即大名鼎鼎的 docker run。</p>
<p>而 -it 参数告诉了 Docker 项目在启动容器后，需要给我们分配一个文本输入 / 输出环境，也就是 TTY，跟容器的标准输入相关联，这样我们就可以和这个 Docker 容器进行交互了。</p>
<p>而 /bin/sh 就是我们要在 Docker 容器里运行的程序。</p>
<p>所以，上面这条指令翻译成人类的语言就是：请帮我启动一个容器，在容器里执行 /bin/sh，并且给我分配一个命令行终端跟这个容器交互。</p>
<h3 id="容器的第一个进程"><a href="#容器的第一个进程" class="headerlink" title="容器的第一个进程"></a>容器的第一个进程</h3><p>我们在讲Dockerfile制作的时候提到过，一个Dockerfile只能一个CMD指令。如果出现多个CMD 则只有最后一个CMD才会生效。因为容器启动的时候第一条命令就是容器内部的第一号进程。</p>
<p>接着上文，如果我们在容器里执行一下 ps 指令，就会发现一些更有趣的事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; # ps</span><br><span class="line">PID USER TIME COMMAND </span><br><span class="line">1 root 0:00 &#x2F;bin&#x2F;sh </span><br><span class="line">10 root 0:00 ps</span><br></pre></td></tr></table></figure>

<p>可以看到，我们在 Docker 里最开始执行的 /bin/sh，就是这个容器内部的第 1 号进程（PID=1），而这个容器里一共只有两个进程在运行。这就意味着，前面执行的 /bin/sh，以及我们刚刚执行的 ps，已经被 Docker 隔离在了一个跟宿主机完全不同的世界当中。</p>
<h3 id="NameSpace的障眼法"><a href="#NameSpace的障眼法" class="headerlink" title="NameSpace的障眼法"></a>NameSpace的障眼法</h3><p>本来，每当我们在宿主机上运行了一个 /bin/sh 程序，操作系统都会给它分配一个进程编号，比如 PID=100。这个编号是进程的唯一标识，就像员工的工牌一样。</p>
<p>所以 PID=100，可以粗略地理解为这个 /bin/sh 是我们公司里的第 100 号员工，而第 1 号员工就自然是比尔 · 盖茨这样统领全局的人物。</p>
<p>而现在，我们要通过 Docker 把这个 /bin/sh 程序运行在一个容器当中。这时候，Docker 就会在这个第 100 号员工入职时给他施一个“障眼法”，让他永远看不到前面的其他 99 个员工，更看不到比尔 · 盖茨。这样，他就会错误地以为自己就是公司里的第 1 号员工。</p>
<p>这种机制，其实就是对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如 PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程。</p>
<p>这种技术，就是 Linux 里面的 Namespace 机制。而 Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建线程的系统调用是 clone()，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pid &#x3D; clone(main_function, stack_size, SIGCHLD, NULL);</span><br></pre></td></tr></table></figure>

<p>这个系统调用就会为我们创建一个新的进程，并且返回它的进程号 pid。</p>
<p>而当我们用 clone() 系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pid &#x3D; clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);</span><br></pre></td></tr></table></figure>
<p>这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。</p>
<p>当然，我们还可以多次执行上面的 clone() 调用，这样就会创建多个 PID Namespace，而每个 Namespace 里的应用进程，都会认为自己是当前容器里的第 1 号进程，它们既看不到宿主机里真正的进程空间，也看不到其他 PID Namespace 里的具体情况。</p>
<h3 id="NameSpace小结"><a href="#NameSpace小结" class="headerlink" title="NameSpace小结"></a>NameSpace小结</h3><p>而除了我们刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。</p>
<p>这，就是 Linux 容器最基本的实现原理了。所以，Docker 容器这个听起来玄而又玄的概念，实际上是在创建容器进程时，指定了这个进程所需要启用的一组 Namespace 参数。这样，容器就只能“看”到当前 Namespace 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。</p>
<p>在理解了 Namespace 的工作方式之后，你就会明白，跟真实存在的虚拟机不同，在使用 Docker 的时候，并没有一个真正的“Docker 容器”运行在宿主机里面。Docker 项目帮助用户启动的，还是原来的应用进程，只不过在创建这些进程时，Docker 为它们加上了各种各样的 Namespace 参数。这时，这些进程就会觉得自己是各自 PID Namespace 里的第 1 号进程，只能看到各自 Mount Namespace 里挂载的目录和文件，只能访问到各自 Network Namespace 里的网络设备，就仿佛运行在一个个“容器”里面，与世隔绝。</p>
<h2 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h2><p>Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。</p>
<p>此外，Cgroups 还能够对进程进行优先级设置、审计，以及将进程挂起和恢复等操作。</p>
<h3 id="操作Cgroups"><a href="#操作Cgroups" class="headerlink" title="操作Cgroups"></a>操作Cgroups</h3><p>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。</p>
<p>指令把它们展示出来，这条命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-28-16 ~]# mount -t cgroup</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent&#x3D;&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd-cgroups-agent,name&#x3D;systemd)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_prio,net_cls)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br></pre></td></tr></table></figure>

<p>可以看到，在 /sys/fs/cgroup 下面有很多诸如 cpuset、cpu、 memory 这样的子目录，也叫子系统。</p>
<p>这些都是我这台机器当前可以被 Cgroups 进行限制的资源种类。而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。比如，对 CPU 子系统来说，我们就可以看到如下几个配置文件，这个指令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-28-16 ~]# ls &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu</span><br><span class="line">cgroup.clone_children  cpuacct.usage         cpu.rt_runtime_us  kubepods.slice     user.slice</span><br><span class="line">cgroup.event_control   cpuacct.usage_percpu  cpu.shares         notify_on_release</span><br><span class="line">cgroup.procs           cpu.cfs_period_us     cpu.stat           release_agent</span><br><span class="line">cgroup.sane_behavior   cpu.cfs_quota_us      docker             system.slice</span><br><span class="line">cpuacct.stat           cpu.rt_period_us      kubepods           tasks</span><br></pre></td></tr></table></figure>

<p>如果熟悉 Linux CPU 管理的话，你就会在它的输出里注意到 cfs_period 和 cfs_quota 这样的关键词。这两个参数需要组合使用，可以用来限制进程在长度为 cfs_period 的一段时间内，只能被分配到总量为 cfs_quota 的 CPU 时间。</p>
<p>而这样的配置文件又如何使用呢？</p>
<p>你需要在对应的子系统下面创建一个目录，比如，我们现在进入 /sys/fs/cgroup/cpu 目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-28-16 cpu]# mkdir test</span><br><span class="line">[root@VM-28-16 cpu]# cd test&#x2F;</span><br><span class="line">[root@VM-28-16 test]# ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 18 17:31 cgroup.clone_children</span><br><span class="line">--w--w--w- 1 root root 0 Jul 18 17:31 cgroup.event_control</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 18 17:31 cgroup.procs</span><br><span class="line">-r--r--r-- 1 root root 0 Jul 18 17:31 cpuacct.stat</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 18 17:31 cpuacct.usage</span><br><span class="line">-r--r--r-- 1 root root 0 Jul 18 17:31 cpuacct.usage_percpu</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 18 17:31 cpu.cfs_period_us</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 18 17:31 cpu.cfs_quota_us</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 18 17:31 cpu.rt_period_us</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 18 17:31 cpu.rt_runtime_us</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 18 17:31 cpu.shares</span><br><span class="line">-r--r--r-- 1 root root 0 Jul 18 17:31 cpu.stat</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 18 17:31 notify_on_release</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul 18 17:31 tasks</span><br></pre></td></tr></table></figure>
<p>这个目录就称为一个“控制组”。你会发现，操作系统会在你新创建的 test 目录下，自动生成该子系统对应的资源限制文件。</p>
<p>现在，我们在后台执行这样一条脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-28-16 test]# while : ; do : ; done &amp;</span><br><span class="line">[1] 32705</span><br><span class="line">[root@VM-28-16 test]# top</span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                    </span><br><span class="line">32705 root      20   0  116496   1632    140 R 100.0  0.0   3:58.89 bash</span><br></pre></td></tr></table></figure>
<p>可以看到CPU的打满了（%Cpu0 :100.0 us）</p>
<p>而此时，我们可以通过查看 test 目录下的文件，看到 container 控制组里的 CPU quota 还没有任何限制（即：-1），CPU period 则是默认的 100 ms（100000 us）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-28-16 test]# cat cpu.cfs_quota_us </span><br><span class="line">-1</span><br><span class="line">[root@VM-28-16 test]# cat cpu.cfs_period_us </span><br><span class="line">100000</span><br></pre></td></tr></table></figure>

<p>接下来，我们可以通过修改这些文件的内容来设置限制。比如，向 test 组里的 cfs_quota 文件写入 20 ms（20000 us）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-28-16 test]# echo 20000 &gt; &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;test&#x2F;cpu.cfs_quota_us</span><br></pre></td></tr></table></figure>

<p>结合前面的介绍，你应该能明白这个操作的含义，它意味着在每 100 ms 的时间里，被该控制组限制的进程只能使用 20 ms 的 CPU 时间，也就是说这个进程只能使用到 20% 的 CPU 带宽。</p>
<p>接下来，我们把被限制的进程的 PID 写入 test 组里的 tasks 文件，上面的设置就会对该进程生效了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-28-16 test]# echo 32705 &gt; &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;test&#x2F;tasks</span><br><span class="line"></span><br><span class="line">[root@VM-28-16 test]# top</span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                    </span><br><span class="line">32705 root      20   0  116496   1632    140 R  20.1  0.0   8:01.77 bash</span><br></pre></td></tr></table></figure>
<p>计算机的 CPU 使用率立刻降到了 20%（%Cpu0 : 20.8 us）。</p>
<h3 id="Cgroups的设计"><a href="#Cgroups的设计" class="headerlink" title="Cgroups的设计"></a>Cgroups的设计</h3><p>除 CPU 子系统外，Cgroups 的每一个子系统都有其独有的资源限制能力，比如：</p>
<ul>
<li>blkio，为块设备设定I/O 限制，一般用于磁盘等设备</li>
<li>cpuset，为进程分配单独的 CPU 核和对应的内存节点</li>
<li>memory，为进程设定内存使用的限制。</li>
</ul>
<p>Linux Cgroups 的设计还是比较易用的，简单粗暴地理解呢，它就是一个子系统目录加上一组资源限制文件的组合。而对于 Docker 等 Linux 容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组（即创建一个新目录），然后在启动容器进程之后，把这个进程的 PID 填写到对应控制组的 tasks 文件中就可以了。</p>
<p>而至于在这些控制组下面的资源文件里填上什么值，就靠用户执行 docker run 时的参数指定了，比如这样一条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --cpu-period&#x3D;100000 --cpu-quota&#x3D;20000 ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>在启动这个容器后，我们可以通过查看 Cgroups 文件系统下，CPU 子系统中，“docker”这个控制组里的资源限制文件的内容来确认：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;5d5c9f67d&#x2F;cpu.cfs_period_us </span><br><span class="line">100000</span><br><span class="line">$ cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;5d5c9f67d&#x2F;cpu.cfs_quota_us </span><br><span class="line">20000</span><br></pre></td></tr></table></figure>

<p>这就意味着这个 Docker 容器，只能使用到 20% 的 CPU 带宽。</p>
<h3 id="Cgroups小结"><a href="#Cgroups小结" class="headerlink" title="Cgroups小结"></a>Cgroups小结</h3><p>一个正在运行的 Docker 容器，其实就是一个启用了多个 Linux Namespace 的应用进程，而这个进程能够使用的资源量，则受 Cgroups 配置的限制。</p>
<h2 id="Union-File-System"><a href="#Union-File-System" class="headerlink" title="Union File System"></a>Union File System</h2><p>作为一个普通用户，我们希望：每当创建一个新容器时，容器里的应用进程，理应看到一份完全独立的文件系统。这样，它就可以在自己的容器目录（比如 /tmp）下进行操作，而完全不会受宿主机以及其他容器的影响。怎么才能做到这一点呢？</p>
<p>上文提到了Namespace里存在一种Mount Namespace</p>
<p>它的存在使我们可以在容器进程启动之前重新挂载它的整个根目录“/”。<br>这个挂载对宿主机不可见，所以容器进程就可以在里面随便折腾了。</p>
<h3 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h3><p>在 Linux 操作系统里，有一个名为 chroot 的命令可以帮助你在 shell 中方便地完成这个工作。顾名思义，它的作用就是帮你“change root file system”，即改变进程的根目录到你指定的位置。它的用法也非常简单。</p>
<p>假设，我们现在有一个 $HOME/test 目录，想要把它作为一个 /bin/bash 进程的根目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">首先，创建一个 test 目录和几个 lib 文件夹：</span><br><span class="line"></span><br><span class="line">mkdir -p $HOME&#x2F;test</span><br><span class="line">mkdir -p $HOME&#x2F;test&#x2F;&#123;bin,lib64,lib&#125;</span><br><span class="line"></span><br><span class="line">然后，把 bash 命令拷贝到 test 目录对应的 bin 路径下</span><br><span class="line"></span><br><span class="line">cp -v &#x2F;bin&#x2F;&#123;bash,ls&#125; $HOME&#x2F;test&#x2F;bin</span><br><span class="line"></span><br><span class="line">接下来，把 bash 命令需要的所有 so 文件，也拷贝到 test 目录对应的 lib 路径下。找到 so 文件可以用 ldd 命令：</span><br><span class="line"></span><br><span class="line">T&#x3D;$HOME&#x2F;test</span><br><span class="line">list&#x3D;&quot;$(ldd &#x2F;bin&#x2F;ls | egrep -o &#39;&#x2F;lib.*\.[0-9]&#39;)&quot;</span><br><span class="line">for i in $list; do cp -v &quot;$i&quot; &quot;$&#123;T&#125;$&#123;i&#125;&quot;; done</span><br><span class="line"></span><br><span class="line">最后，执行 chroot 命令，告诉操作系统，我们将使用 $HOME&#x2F;test 目录作为 &#x2F;bin&#x2F;bash 进程的根目录：</span><br><span class="line"></span><br><span class="line">chroot $HOME&#x2F;test &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>这时，你如果执行 “ls /“，就会看到，它返回的都是 $HOME/test 目录下面的内容，而不是宿主机的内容。</p>
<p>更重要的是，对于被 chroot 的进程来说，它并不会感受到自己的根目录已经被“修改”成 $HOME/test 了。</p>
<h3 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h3><p>实际上，Mount Namespace 正是基于对 chroot 的不断改良才被发明出来的，它也是 Linux 操作系统里的第一个 Namespace。</p>
<p>而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。</p>
<p>所以，一个最常见的 rootfs，或者说容器镜像，会包括如下所示的一些目录和文件，比如 /bin，/etc，/proc 等等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls &#x2F;</span><br><span class="line">bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var</span><br></pre></td></tr></table></figure>

<p>现在，你应该可以理解，对 Docker 项目来说，它最核心的原理实际上就是为待创建的用户进程：</p>
<ul>
<li>启用 Linux Namespace 配置；</li>
<li>设置指定的 Cgroups 参数</li>
<li>切换进程的根目录（Change Root）。</li>
</ul>
<p>另外，需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。</p>
<p>在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。</p>
<h3 id="容器的一致性"><a href="#容器的一致性" class="headerlink" title="容器的一致性"></a>容器的一致性</h3><p>正是由于 rootfs 的存在，容器才有了一个被反复宣传至今的重要特性：一致性。</p>
<p>什么是容器的“一致性”呢？</p>
<p>由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。</p>
<p>有了容器镜像“打包操作系统”的能力，这个最基础的依赖环境也终于变成了应用沙盒的一部分。这就赋予了容器所谓的一致性：无论在本地、云端，还是在一台任何地方的机器上，用户只需要解压打包好的容器镜像，那么这个应用运行所需要的完整的执行环境就被重现出来了。</p>
<p>这种深入到操作系统级别的运行环境一致性，打通了应用在本地开发和远端执行环境之间难以逾越的鸿沟。</p>
<h3 id="联合文件系统（Union-File-System）到底是怎么回事"><a href="#联合文件系统（Union-File-System）到底是怎么回事" class="headerlink" title="联合文件系统（Union File System）到底是怎么回事"></a>联合文件系统（Union File System）到底是怎么回事</h3><p>Docker 在镜像的设计中，引入了层（layer）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。</p>
<p>Union File System 也叫 UnionFS，最主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下。比如，我现在有两个目录 A 和 B，它们分别有两个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test1]# tree</span><br><span class="line">.</span><br><span class="line">├── A</span><br><span class="line">│   ├── a</span><br><span class="line">│   └── x</span><br><span class="line">└── B</span><br><span class="line">    ├── b</span><br><span class="line">    └── x</span><br><span class="line"></span><br><span class="line">然后，我使用联合挂载的方式，将这两个目录挂载到一个公共的目录 C 上：</span><br><span class="line"></span><br><span class="line">[root@localhost test1]# mkdir C</span><br><span class="line">[root@localhost test1]# mount -t aufs -o dirs&#x3D;.&#x2F;A:.&#x2F;B none .&#x2F;C</span><br><span class="line">[root@localhost test1]# tree .&#x2F;C</span><br><span class="line">.&#x2F;C</span><br><span class="line">├── a</span><br><span class="line">├── b</span><br><span class="line">└── x</span><br><span class="line"></span><br><span class="line">可以看到，在这个合并后的目录 C 里，有 a、b、x 三个文件，并且 x 文件只有一份。</span><br><span class="line"></span><br><span class="line">这，就是“合并”的含义。此外，如果你在目录 C 里对 a、b、x 文件做修改，这些修改也会在对应的目录 A、B 中生效。</span><br></pre></td></tr></table></figure>

<h3 id="Docker-Image的底层原理"><a href="#Docker-Image的底层原理" class="headerlink" title="Docker Image的底层原理"></a>Docker Image的底层原理</h3><p>现在，我们启动一个容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -d ubuntu:latest sleep 3600</span><br><span class="line">693d8e17e996e08819c0504ce01f0b58c7e67918e8346255b3cf2fddfb8800af</span><br></pre></td></tr></table></figure>

<p>此时的Docker Image，实际上就是一个 Ubuntu 操作系统的 rootfs，它的内容是 Ubuntu 操作系统的所有文件和目录。</p>
<p>不过，与之前我们讲述的 rootfs 稍微不同的是，Docker 镜像使用的 rootfs，往往由多个“层”组成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test1]# docker image inspect ubuntu:latest</span><br><span class="line">...</span><br><span class="line">        &quot;RootFS&quot;: &#123;</span><br><span class="line">            &quot;Type&quot;: &quot;layers&quot;,</span><br><span class="line">            &quot;Layers&quot;: [</span><br><span class="line">                &quot;sha256:e1c75a5e0bfa094c407e411eb6cc8a159ee8b060cbd0398f1693978b4af9af10&quot;,</span><br><span class="line">                &quot;sha256:9e97312b63ff63ad98bb1f3f688fdff0721ce5111e7475b02ab652f10a4ff97d&quot;,</span><br><span class="line">                &quot;sha256:ec1817c93e7c08d27bfee063f0f1349185a558b87b2d806768af0a8fbbf5bc11&quot;,</span><br><span class="line">                &quot;sha256:05f3b67ed530c5b55f6140dfcdfb9746cdae7b76600de13275197d009086bb3d&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Metadata&quot;: &#123;</span><br><span class="line">            &quot;LastTagTime&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>可以看到，这个 Ubuntu 镜像，实际上由四层组成。这四层就是四个增量 rootfs，每一层都是 Ubuntu 操作系统文件与目录的一部分；而在使用镜像时，Docker 会把这些增量联合挂载在一个统一的挂载点上（等价于前面例子里的“/C”目录）。</p>
<p>overlay2是最新的Docker CE版本18.06.0上的默认存储驱动。</p>
<p>这个挂载点就是/var/lib/docker/overlay2</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#下载Ubuntu后的图层</span><br><span class="line">[root@localhost overlay2]# ll</span><br><span class="line">total 0</span><br><span class="line">drwx------ 4 root root     72 Jul 19 19:22 02dccddd7184a977f6a105f849ecfa69753e62e3931628325249bf2fa013524f</span><br><span class="line">drwx------ 4 root root     55 Jul 19 19:22 930e827392a2b099d8b2d4c4431b1a6b8685bbfdca55b97c5522906170c78f72</span><br><span class="line">brw------- 1 root root 253, 0 Jun  1 15:10 backingFsBlockDev</span><br><span class="line">drwx------ 4 root root     72 Jul 19 19:22 cc3d690e853be0c422705cd4e449a30bdc4a121db5fc9d8e1c433f6071756111</span><br><span class="line">drwx------ 3 root root     47 Jul 19 19:22 fecbaa2f5e0fff06b09a6164443a50bad7829c484d5c5db732fd51abc4506beb</span><br><span class="line">drwx------ 2 root root    142 Jul 19 19:22 l</span><br><span class="line"></span><br><span class="line">#启动一个Ubuntu镜像的容器</span><br><span class="line">[root@localhost overlay2]# docker run -d ubuntu:latest sleep 3600</span><br><span class="line"></span><br><span class="line">#启动后的图层</span><br><span class="line">[root@localhost overlay2]# ll</span><br><span class="line">total 0</span><br><span class="line">drwx------ 4 root root     72 Jul 19 19:22 02dccddd7184a977f6a105f849ecfa69753e62e3931628325249bf2fa013524f</span><br><span class="line">drwx------ 4 root root     72 Jul 19 20:12 930e827392a2b099d8b2d4c4431b1a6b8685bbfdca55b97c5522906170c78f72</span><br><span class="line">brw------- 1 root root 253, 0 Jun  1 15:10 backingFsBlockDev</span><br><span class="line">drwx------ 4 root root     72 Jul 19 19:22 cc3d690e853be0c422705cd4e449a30bdc4a121db5fc9d8e1c433f6071756111</span><br><span class="line">drwx------ 5 root root     69 Jul 19 20:12 e9165a3fd83378e53b1dfe4c72c3c5003d4d165a4acfd80b265f8c455bb31bbc</span><br><span class="line">drwx------ 4 root root     72 Jul 19 20:12 e9165a3fd83378e53b1dfe4c72c3c5003d4d165a4acfd80b265f8c455bb31bbc-init</span><br><span class="line">drwx------ 3 root root     47 Jul 19 19:22 fecbaa2f5e0fff06b09a6164443a50bad7829c484d5c5db732fd51abc4506beb</span><br><span class="line">drwx------ 2 root root    210 Jul 19 20:12 l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你会发现新增了2个目录，即被联合挂载之后形成新的目录</span><br><span class="line">进入目录后可以看见，这个里面就是容器里的东西</span><br><span class="line"></span><br><span class="line">[root@localhost merged]# pwd</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;e9165a3fd83378e53b1dfe4c72c3c5003d4d165a4acfd80b265f8c455bb31bbc&#x2F;merged</span><br><span class="line">[root@localhost merged]# ll</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root  7 Jul  3 09:56 bin -&gt; usr&#x2F;bin</span><br><span class="line">drwxr-xr-x 2 root root  6 Apr 15 19:09 boot</span><br><span class="line">drwxr-xr-x 1 root root 43 Jul 19 20:12 dev</span><br><span class="line">drwxr-xr-x 1 root root 66 Jul 19 20:12 etc</span><br><span class="line">drwxr-xr-x 2 root root  6 Apr 15 19:09 home</span><br><span class="line">lrwxrwxrwx 1 root root  7 Jul  3 09:56 lib -&gt; usr&#x2F;lib</span><br><span class="line">lrwxrwxrwx 1 root root  9 Jul  3 09:56 lib32 -&gt; usr&#x2F;lib32</span><br><span class="line">lrwxrwxrwx 1 root root  9 Jul  3 09:56 lib64 -&gt; usr&#x2F;lib64</span><br><span class="line">lrwxrwxrwx 1 root root 10 Jul  3 09:56 libx32 -&gt; usr&#x2F;libx32</span><br><span class="line">drwxr-xr-x 2 root root  6 Jul  3 09:57 media</span><br><span class="line">drwxr-xr-x 2 root root  6 Jul  3 09:57 mnt</span><br><span class="line">drwxr-xr-x 2 root root  6 Jul  3 09:57 opt</span><br><span class="line">drwxr-xr-x 2 root root  6 Apr 15 19:09 proc</span><br><span class="line">drwx------ 2 root root 37 Jul  3 10:00 root</span><br><span class="line">drwxr-xr-x 1 root root 21 Jul  7 05:56 run</span><br><span class="line">lrwxrwxrwx 1 root root  8 Jul  3 09:56 sbin -&gt; usr&#x2F;sbin</span><br><span class="line">drwxr-xr-x 2 root root  6 Jul  3 09:57 srv</span><br><span class="line">drwxr-xr-x 2 root root  6 Apr 15 19:09 sys</span><br><span class="line">drwxrwxrwt 2 root root  6 Jul  3 10:00 tmp</span><br><span class="line">drwxr-xr-x 1 root root 18 Jul  3 09:57 usr</span><br><span class="line">drwxr-xr-x 1 root root 17 Jul  3 10:00 var</span><br></pre></td></tr></table></figure>

<p>那么，前面提到的五个镜像层，又是如何被联合挂载成这样一个完整的 Ubuntu 文件系统的呢？</p>
<p>可以查询挂载的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost merged]# cat &#x2F;proc&#x2F;mounts| grep overlay2</span><br><span class="line">overlay &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;e9165a3fd83378e53b1dfe4c72c3c5003d4d165a4acfd80b265f8c455bb31bbc&#x2F;merged </span><br><span class="line">overlay rw,relatime,</span><br><span class="line">lowerdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;X644A6N6JAYX6FLP76U6HFD3HQ:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;K4OIX32VD6WIAQ7R6LLXJXRVLQ:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;IJGD7NOFAJBGJFMMOCZVG7OXNC:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;OR4MXA5Z63JQCCXOQRSCFYMY2U:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;CPSWVQCU3X4JZWB3XEXL7TULDW,</span><br><span class="line">upperdir&#x3D;&#x2F;var&#x2F;lib&#x2F;dockeroverlay2&#x2F;e9165a3fd83378e53b1dfe4c72c3c5003d4d165a4acfd80b265f8c455bb31bbc&#x2F;diff,</span><br><span class="line">workdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;e9165a3fd83378e53b1dfe4c72c3c5003d4d165a4acfd80b265f8c455bb31bbc&#x2F;work 0 0</span><br><span class="line"></span><br><span class="line">[root@localhost overlay2]# df -h</span><br><span class="line">overlay                  200G  4.3G  196G   3% &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;e9165a3fd83378e53b1dfe4c72c3c5003d4d165a4acfd80b265f8c455bb31bbc&#x2F;merged</span><br></pre></td></tr></table></figure>

<h3 id="一个容器的组成部分"><a href="#一个容器的组成部分" class="headerlink" title="一个容器的组成部分"></a>一个容器的组成部分</h3><p>OverlayFS在单个Linux主机上分层两个目录，并将它们显示为单个目录。这些目录称为图层，统一过程称为联合安装。OverlayFS指的是下层lowerdir目录a和上层目录a upperdir。统一视图通过其自己的目录公开merged。</p>
<p>镜像层（只读）是lowerdir，容器层（读写）是upperdir</p>
<ul>
<li>lower文件指向镜像层，即Ove​​rlayFS lowerdir。</li>
<li>upper文件指向容器层，该层对应于OverlayFS upperdir。</li>
<li>merged目录是联合安装的lowerdir和upperdir的挂载点，该方法包括从正在运行的容器内的文件系统的镜像。</li>
<li>work目录在OverlayFS内部。用于实现copy_up操作。</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Docker/overlay_constructs.jpg"  alt="overlay_constructs.jpg"></p>
<p>启动后的容器分为3层</p>
<ul>
<li>第一部分，只读层。</li>
</ul>
<p>它是这个容器的 rootfs 最下面的四层，对应的正是 ubuntu:latest 镜像的四层。它们的挂载方式都是只读的（ro+wh，即 readonly+whiteout，至于什么是 whiteout，我下面马上会讲到）。这些层，都以增量的方式分别包含了 Ubuntu 操作系统的一部分。</p>
<ul>
<li>第二部分，可读写层。</li>
</ul>
<p>它是这个容器的 rootfs 最上面的一层（6e3be5d2ecccae7cc），它的挂载方式为：rw，即 read write。</p>
<p>可是，你有没有想到这样一个问题：如果我现在要做的，是删除只读层里的一个文件呢？</p>
<p>为了实现这样的删除操作，AuFS 会在可读写层创建一个 whiteout 文件，把只读层里的文件“遮挡”起来。</p>
<p>比如，你要删除只读层里一个名叫 foo 的文件，那么这个删除操作实际上是在可读写层创建了一个名叫.wh.foo 的文件。这样，当这两个层被联合挂载之后，foo 文件就会被.wh.foo 文件“遮挡”起来，“消失”了。这个功能，就是“ro+wh”的挂载方式，即只读 +whiteout 的含义。我喜欢把 whiteout 形象地翻译为：“白障”。</p>
<p>在没有写入文件之前，这个目录是空的。而一旦在容器里做了写操作，你修改产生的内容就会以增量的方式出现在这个层中。最上面这个可读写层的作用，就是专门用来存放你修改 rootfs 后产生的增量，无论是增、删、改，都发生在这里。而当我们使用完了这个被修改过的容器之后，还可以使用 docker commit 和 push 指令，保存这个被修改过的可读写层，并上传到 Docker Hub 上，供其他人使用；而与此同时，原先的只读层里的内容则不会有任何变化。这，就是增量 rootfs 的好处。</p>
<ul>
<li>第三部分，Init 层。它是一个以“-init”结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息。需要这样一层的原因是，这些文件本来属于只读的 Ubuntu 镜像的一部分，但是用户往往需要在启动容器时写入一些指定的值比如 hostname，所以就需要在可读写层对它们进行修改。可是，这些修改往往只对当前的容器有效，我们并不希望执行 docker commit 时，把这些信息连同可读写层一起提交掉。所以，Docker 做法是，在修改了这些文件之后，以一个单独的层挂载了出来。而用户执行 docker commit 只会提交可读写层，所以是不包含这些内容的。最终，这 7 个层都被联合挂载到 /var/lib/docker/aufs/mnt 目录下，表现为一个完整的 Ubuntu 操作系统供容器使用。</li>
</ul>
<p>具体细节后面我会深入讲解，这里就不重点讲了</p>
<p>可以参考官方文档 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank" rel="noopener">使用OverlayFS存储驱动程序</a></p>
<p>所以搞清楚一点即可</p>
<p>镜像的层都放置在 /var/lib/docker/overlay2/分层ID/diff 目录下，然后启动容器后被联合挂载在  /var/lib/docker/overlay2/联合层ID/merge 里面。</p>
<h3 id="UFS小结"><a href="#UFS小结" class="headerlink" title="UFS小结"></a>UFS小结</h3><p>容器镜像，也叫作：ufs（有的人喜欢叫rootfs）。它只是一个操作系统的所有文件和目录，并不包含内核，最多也就几百兆。而相比之下，传统虚拟机的镜像大多是一个磁盘的“快照”，磁盘有多大，镜像就至少有多大。</p>
<p>通过结合使用 Mount Namespace 和 rootfs，容器就能够为进程构建出一个完善的文件系统隔离环境。当然，这个功能的实现还必须感谢 chroot 和 pivot_root 这两个系统调用切换进程根目录的能力。</p>
<p>而在 rootfs 的基础上，Docker 公司创新性地提出了使用多个增量 rootfs 联合挂载一个完整 rootfs 的方案，这就是容器镜像中“层”的概念。</p>
<p>通过“分层镜像”的设计，以 Docker 镜像为核心，来自不同公司、不同团队的技术人员被紧密地联系在了一起。而且，由于容器镜像的操作是增量式的，这样每次镜像拉取、推送的内容，比原本多个完整的操作系统的大小要小得多；而共享层的存在，可以使得所有这些容器镜像需要的总空间，也比每个镜像的总和要小。这样就使得基于容器镜像的团队协作，要比基于动则几个 GB 的虚拟机磁盘镜像的协作要敏捷得多。</p>
<p>更重要的是，一旦这个镜像被发布，那么你在全世界的任何一个地方下载这个镜像，得到的内容都完全一致，可以完全复现这个镜像制作者当初的完整环境。这，就是容器技术“强一致性”的重要体现。</p>
<h1 id="Docker存在的问题"><a href="#Docker存在的问题" class="headerlink" title="Docker存在的问题"></a>Docker存在的问题</h1><p>我们既然要重新了解Docker，它的一些缺点注定是我们绕不过去的，首先，容器不是万能的，不然要虚拟机干嘛。我也是通过容器的3个技术分析它们的劣势</p>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><ul>
<li>Namespace隔离得不彻底，首先，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核。</li>
<li>在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。</li>
</ul>
<p>如果你的容器中的程序使用 settimeofday(2) 系统调用修改了时间，整个宿主机的时间都会被随之修改，这显然不符合用户的预期。相比于在虚拟机里面可以随便折腾的自由度，在容器里部署应用的时候，“什么能做，什么不能做”，就是用户必须考虑的一个问题。</p>
<p>由于一个容器的本质就是一个进程，用户的应用进程实际上就是容器里 PID=1 的进程，也是其他后续创建的所有进程的父进程。这就意味着，在一个容器中，你没办法同时运行两个不同的应用，除非你能事先找到一个公共的 PID=1 的程序来充当两个不同应用的父进程，这也是为什么很多人都会用 systemd 或者 supervisord 这样的软件来代替应用本身作为容器的启动进程。</p>
<p>但是，在后面分享容器设计模式时，我还会推荐其他更好的解决办法。这是因为容器本身的设计，就是希望容器和应用能够同生命周期，这个概念对后续的容器编排非常重要。否则，一旦出现类似于“容器是正常运行的，但是里面的应用早已经挂了”的情况，编排系统处理起来就非常麻烦了。</p>
<h2 id="Cgroups-1"><a href="#Cgroups-1" class="headerlink" title="Cgroups"></a>Cgroups</h2><p>Cgroups 对资源的限制能力也有很多不完善的地方，被提及最多的自然是 /proc 文件系统的问题。</p>
<p>众所周知，Linux 下的 /proc 目录存储的是记录当前内核运行状态的一系列特殊文件，用户可以通过访问这些文件，查看系统以及当前正在运行的进程的信息，比如 CPU 使用情况、内存占用率等，这些文件也是 top 指令查看系统信息的主要数据来源。</p>
<p>但是，你如果在容器里执行 top 指令，就会发现，它显示的信息居然是宿主机的 CPU 和内存数据，而不是当前容器的数据。造成这个问题的原因就是，/proc 文件系统并不知道用户通过 Cgroups 给这个容器做了什么样的资源限制，即：/proc 文件系统不了解 Cgroups 限制的存在。</p>
<p>在生产环境中，这个问题必须进行修正，否则应用程序在容器里读取到的 CPU 核数、可用内存等信息都是宿主机上的数据，这会给应用的运行带来非常大的困惑和风险。</p>
<h2 id="UFS"><a href="#UFS" class="headerlink" title="UFS"></a>UFS</h2><p>上面的读写层通常也称为容器层，下面的只读层称为镜像层，所有的增删查改操作都只会作用在容器层，相同的文件上层会覆盖掉下层。</p>
<p>知道这一点，就不难理解镜像文件的修改，比如修改一个文件的时候，首先会从上到下查找有没有这个文件，找到，就复制到容器层中，修改，修改的结果就会作用到下层的文件，这种方式也被称为copy-on-write。</p>
<p>但是如果你的底层镜像发生变化，可能牵一发而动全身。因为其他的镜像如果都按照一个基础镜像的制作，那么这个改变会影响很多现有镜像。</p>
<p>比如我们现在java项目的环境依赖jdk1.7，由于项目的升级及其他原因，导致了jdk1.7必须升级到1.8才能完成，但是并不是所有的项目都需要升级。</p>
<p>应对这种情况就必须要更加细致化的区分基础镜像。</p>
<p>比如制作一个centos7的镜像</p>
<p>基于这个镜像制作一个jdk1.7 和一个jdk1.8 2个不同的基础镜像</p>
<p>然后项目分别跑着不同的基础环境中。</p>
<p>而虚拟机可以随意切换环境，重新启动项目即可。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>容器，其实是一种特殊的进程而已。</p>
<p>Namespace 的作用是“隔离”，它让应用进程只能看到该 Namespace 内的“世界”</p>
<p>而 Cgroups 的作用是“限制”，它给这个“世界”围上了一圈看不见的墙。这么一折腾，进程就真的被“装”在了一个与世隔绝的房间里，而这些房间就是 PaaS 项目赖以生存的应用“沙盒”。</p>
<p>通过结合使用 Mount Namespace 和 rootfs，容器就能够为进程构建出一个完善的文件系统隔离环境。</p>
<p>通过这样的剖析，对于曾经“神秘莫测”的容器技术，你是不是感觉清晰了很多呢？</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank" rel="noopener">使用OverlayFS存储驱动程序</a></p>
<p><a href="https://time.geekbang.org/column/intro/116" target="_blank" rel="noopener">深入剖析Kubernetes
</a></p>
<hr>
<p>版权声明：</p>
<p>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Rugod</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rugod.com/2020/07/19/docker/docker-idea-6/">https://rugod.com/2020/07/19/docker/docker-idea-6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rugod.com" target="_blank">宇神之息</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E5%AE%B9%E5%99%A8/">容器</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/SLB/nginx.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/wechat.JPG" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/alipay.JPG" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/22/bug/dockerfile-time-zone/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/problem-solving.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">运维手册——Kubernetes容器时区不同步</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/18/kubernetes/Kubernetes-introduction-3/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/kubernetes.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Kubernetes入门篇(三)——Kubernetes的对象和API</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/24/docker/docker-idea-1/" title="深入浅出Docker原理及实战(一)——Docker的基本理念与原理"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-07-12</div><div class="relatedPosts_title">深入浅出Docker原理及实战(一)——Docker的基本理念与原理</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/27/docker/docker-idea-3/" title="深入浅出Docker原理及实战(三)——制作Dockerfile"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-07-12</div><div class="relatedPosts_title">深入浅出Docker原理及实战(三)——制作Dockerfile</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/09/docker/docker-idea-2/" title="深入浅出Docker原理及实战(二)——Docker的安装及常用命令"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-07-12</div><div class="relatedPosts_title">深入浅出Docker原理及实战(二)——Docker的安装及常用命令</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/gh/xaoxuu/volantis/js/volantis.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'GkD8YSRxxCgXoW6LqFO3cKhd-gzGzoHsz',
  appKey: 'DbbNrHwsCuK9Ehh2wgOw6UXL',
  placeholder: '记得留下你的昵称和邮箱...可以快速收到回复哦',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/chenyu1st/chenyu-cdn@master/rugod.cn/Blog/docker.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Rugod</div><div class="footer_custom_text">弱小的人才习惯嘲讽和否定，而内心强大的人从不吝啬赞美和鼓励</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="255,0,0" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script></body></html>